<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BehaviorTree: BT Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BehaviorTree
   </div>
   <div id="projectbrief">Core Library to create and execute Behavior Trees</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d2/d8d/namespace_b_t.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">BT Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:df/da8/namespace_b_t_1_1details"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da8/namespace_b_t_1_1details.html">details</a></td></tr>
<tr class="memdesc:df/da8/namespace_b_t_1_1details"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dc/dae/class_b_t_1_1_switch_node.html">SwitchNode</a> is equivalent to a switch statement, where a certain branch (child) is executed according to the value of a blackboard entry. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de2/class_b_t_1_1_action_node_base.html">ActionNodeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d3/de2/class_b_t_1_1_action_node_base.html" title="The ActionNodeBase is the base class to use to create any kind of action. A particular derived class ...">ActionNodeBase</a> is the base class to use to create any kind of action. A particular derived class is free to override <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html#a07d0876cfd608b690650e930d1a629cc" title="The method that should be used to invoke tick() and setStatus();.">executeTick()</a> as needed.  <a href="../../d3/de2/class_b_t_1_1_action_node_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9c/class_b_t_1_1_always_failure_node.html">AlwaysFailureNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dce/class_b_t_1_1_always_success_node.html">AlwaysSuccessNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/struct_b_t_1_1_any_type_allowed.html">AnyTypeAllowed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d93/class_b_t_1_1_behavior_tree_exception.html">BehaviorTreeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html">BehaviorTreeFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html" title="The BehaviorTreeFactory is used to create instances of a TreeNode at run-time.">BehaviorTreeFactory</a> is used to create instances of a <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html" title="Abstract base class for Behavior Tree Nodes.">TreeNode</a> at run-time.  <a href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html">Blackboard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html" title="The Blackboard is the mechanism used by BehaviorTrees to exchange typed data.">Blackboard</a> is the mechanism used by BehaviorTrees to exchange typed data.  <a href="../../d0/d51/class_b_t_1_1_blackboard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfc/class_b_t_1_1_condition_node.html">ConditionNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dc2/class_b_t_1_1_consume_queue.html">ConsumeQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/ddb/class_b_t_1_1_control_node.html">ControlNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd4/class_b_t_1_1_coro_action_node.html">CoroActionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d8/dd4/class_b_t_1_1_coro_action_node.html" title="The CoroActionNode class is an a good candidate for asynchronous actions which need to communicate wi...">CoroActionNode</a> class is an a good candidate for asynchronous actions which need to communicate with an external service using an async request/reply interface.  <a href="../../d8/dd4/class_b_t_1_1_coro_action_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de7/class_b_t_1_1_decorator_node.html">DecoratorNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d56/class_b_t_1_1_delay_node.html">DelayNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The delay node will introduce a delay and then tick the child returning the status of the child as it is upon completion The delay is in milliseconds and it is passed using the port "delay_msec".  <a href="../../d4/d56/class_b_t_1_1_delay_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d9f/class_b_t_1_1_entry_updated_action.html">EntryUpdatedAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../df/d9f/class_b_t_1_1_entry_updated_action.html" title="The EntryUpdatedAction checks the Timestamp in an entry to determine if the value was updated since t...">EntryUpdatedAction</a> checks the <a class="el" href="../../d0/d59/struct_b_t_1_1_timestamp.html">Timestamp</a> in an entry to determine if the value was updated since the last time.  <a href="../../df/d9f/class_b_t_1_1_entry_updated_action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d7b/class_b_t_1_1_entry_updated_decorator.html">EntryUpdatedDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d1/d7b/class_b_t_1_1_entry_updated_decorator.html" title="The EntryUpdatedDecorator checks the Timestamp in an entry to determine if the value was updated sinc...">EntryUpdatedDecorator</a> checks the <a class="el" href="../../d0/d59/struct_b_t_1_1_timestamp.html">Timestamp</a> in an entry to determine if the value was updated since the last time (true, the first time).  <a href="../../d1/d7b/class_b_t_1_1_entry_updated_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da6/class_b_t_1_1_fallback_node.html">FallbackNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dc/da6/class_b_t_1_1_fallback_node.html" title="The FallbackNode is used to try different strategies, until one succeeds. If any child returns RUNNIN...">FallbackNode</a> is used to try different strategies, until one succeeds. If any child returns RUNNING, previous children will NOT be ticked again.  <a href="../../dc/da6/class_b_t_1_1_fallback_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d7b/class_b_t_1_1_file_logger2.html">FileLogger2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d2/d7b/class_b_t_1_1_file_logger2.html" title="The FileLogger2 is a logger that saves the tree as XML and all the transitions. Data is written to fi...">FileLogger2</a> is a logger that saves the tree as XML and all the transitions. Data is written to file in a separate thread, to minimize latency.  <a href="../../d2/d7b/class_b_t_1_1_file_logger2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8c/class_b_t_1_1_force_failure_node.html">ForceFailureNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d4/d8c/class_b_t_1_1_force_failure_node.html" title="The ForceFailureNode returns always FAILURE or RUNNING.">ForceFailureNode</a> returns always FAILURE or RUNNING.  <a href="../../d4/d8c/class_b_t_1_1_force_failure_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db8/class_b_t_1_1_force_success_node.html">ForceSuccessNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d7/db8/class_b_t_1_1_force_success_node.html" title="The ForceSuccessNode returns always SUCCESS or RUNNING.">ForceSuccessNode</a> returns always SUCCESS or RUNNING.  <a href="../../d7/db8/class_b_t_1_1_force_success_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/df5/class_b_t_1_1_groot2_publisher.html">Groot2Publisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../da/df5/class_b_t_1_1_groot2_publisher.html" title="The Groot2Publisher is used to create an interface between your BT.CPP executor and Groot2.">Groot2Publisher</a> is used to create an interface between your BT.CPP executor and Groot2.  <a href="../../da/df5/class_b_t_1_1_groot2_publisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da6/struct_b_t_1_1has__static__method__metadata.html">has_static_method_metadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/struct_b_t_1_1has__static__method__metadata_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1065d166f8cc1b3c83dbdb1c2230484f1.html">has_static_method_metadata&lt; T, typename std::enable_if&lt; std::is_same&lt; decltype(T::metadata()), KeyValueVector &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d56/struct_b_t_1_1has__static__method__provided_ports.html">has_static_method_providedPorts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d07/struct_b_t_1_1has__static__method__provided_ports_3_01_t_00_01typename_01std_1_1enable__if_3_01s8432b5486894de4ea455ef2f702667bd.html">has_static_method_providedPorts&lt; T, typename std::enable_if&lt; std::is_same&lt; decltype(T::providedPorts()), PortsList &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d08/class_b_t_1_1_if_then_else_node.html">IfThenElseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/d08/class_b_t_1_1_if_then_else_node.html" title="IfThenElseNode must have exactly 2 or 3 children. This node is NOT reactive.">IfThenElseNode</a> must have exactly 2 or 3 children. This node is NOT reactive.  <a href="../../d8/d08/class_b_t_1_1_if_then_else_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ded/class_b_t_1_1_inverter_node.html">InverterNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d2/ded/class_b_t_1_1_inverter_node.html" title="The InverterNode returns SUCCESS if child fails of FAILURE is child succeeds. RUNNING status is propa...">InverterNode</a> returns SUCCESS if child fails of FAILURE is child succeeds. RUNNING status is propagated.  <a href="../../d2/ded/class_b_t_1_1_inverter_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d64/class_b_t_1_1_json_exporter.html">JsonExporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d22/class_b_t_1_1_keep_running_until_failure_node.html">KeepRunningUntilFailureNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../de/d22/class_b_t_1_1_keep_running_until_failure_node.html" title="The KeepRunningUntilFailureNode returns always FAILURE or RUNNING.">KeepRunningUntilFailureNode</a> returns always FAILURE or RUNNING.  <a href="../../de/d22/class_b_t_1_1_keep_running_until_failure_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de2/class_b_t_1_1_leaf_node.html">LeafNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d98/class_b_t_1_1_locked_ptr.html">LockedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d4/d98/class_b_t_1_1_locked_ptr.html" title="The LockedPtr class is used to share a pointer to an object and a mutex that protects the read/write ...">LockedPtr</a> class is used to share a pointer to an object and a mutex that protects the read/write access to that object.  <a href="../../d4/d98/class_b_t_1_1_locked_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4f/class_b_t_1_1_logic_error.html">LogicError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d32/class_b_t_1_1_loop_node.html">LoopNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dd/d32/class_b_t_1_1_loop_node.html" title="The LoopNode class is used to pop_front elements from a std::deque. This element is copied into the p...">LoopNode</a> class is used to pop_front elements from a std::deque. This element is copied into the port "value" and the child will be executed, as long as we have elements in the queue.  <a href="../../dd/d32/class_b_t_1_1_loop_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0b/class_b_t_1_1_manual_selector_node.html">ManualSelectorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a Terminal User Interface (ncurses) to select a certain child manually.  <a href="../../dc/d0b/class_b_t_1_1_manual_selector_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d4f/class_b_t_1_1_minitrace_logger.html">MinitraceLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d26/struct_b_t_1_1_node_config.html">NodeConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d02/class_b_t_1_1_parallel_all_node.html">ParallelAllNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d3/d02/class_b_t_1_1_parallel_all_node.html" title="The ParallelAllNode execute all its children concurrently, but not in separate threads!">ParallelAllNode</a> execute all its children <b>concurrently</b>, but not in separate threads!  <a href="../../d3/d02/class_b_t_1_1_parallel_all_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dee/class_b_t_1_1_parallel_node.html">ParallelNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d1/dee/class_b_t_1_1_parallel_node.html" title="The ParallelNode execute all its children concurrently, but not in separate threads!">ParallelNode</a> execute all its children <b>concurrently</b>, but not in separate threads!  <a href="../../d1/dee/class_b_t_1_1_parallel_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da6/class_b_t_1_1_parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The BehaviorTreeParser is a class used to read the model of a BehaviorTree from file or text and instantiate the corresponding tree using the <a class="el" href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html" title="The BehaviorTreeFactory is used to create instances of a TreeNode at run-time.">BehaviorTreeFactory</a>.  <a href="../../de/da6/class_b_t_1_1_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3a/class_b_t_1_1_pop_from_queue.html">PopFromQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd5/class_b_t_1_1_precondition_node.html">PreconditionNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dee/struct_b_t_1_1_protected_queue.html">ProtectedQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8c/class_b_t_1_1_queue_size.html">QueueSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d04/class_b_t_1_1_reactive_fallback.html">ReactiveFallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dc/d04/class_b_t_1_1_reactive_fallback.html" title="The ReactiveFallback is similar to a ParallelNode. All the children are ticked from first to last:">ReactiveFallback</a> is similar to a <a class="el" href="../../d1/dee/class_b_t_1_1_parallel_node.html" title="The ParallelNode execute all its children concurrently, but not in separate threads!">ParallelNode</a>. All the children are ticked from first to last:  <a href="../../dc/d04/class_b_t_1_1_reactive_fallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d9f/class_b_t_1_1_reactive_sequence.html">ReactiveSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../de/d9f/class_b_t_1_1_reactive_sequence.html" title="The ReactiveSequence is similar to a ParallelNode. All the children are ticked from first to last:">ReactiveSequence</a> is similar to a <a class="el" href="../../d1/dee/class_b_t_1_1_parallel_node.html" title="The ParallelNode execute all its children concurrently, but not in separate threads!">ParallelNode</a>. All the children are ticked from first to last:  <a href="../../de/d9f/class_b_t_1_1_reactive_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d78/class_b_t_1_1_repeat_node.html">RepeatNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d6/d78/class_b_t_1_1_repeat_node.html" title="The RepeatNode is used to execute a child several times, as long as it succeed.">RepeatNode</a> is used to execute a child several times, as long as it succeed.  <a href="../../d6/d78/class_b_t_1_1_repeat_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de4/class_b_t_1_1_retry_node.html">RetryNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dd/de4/class_b_t_1_1_retry_node.html" title="The RetryNode is used to execute a child several times if it fails.">RetryNode</a> is used to execute a child several times if it fails.  <a href="../../dd/de4/class_b_t_1_1_retry_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/def/class_b_t_1_1_retry_node_typo.html">RetryNodeTypo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dbd/class_b_t_1_1_run_once_node.html">RunOnceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dd/dbd/class_b_t_1_1_run_once_node.html" title="The RunOnceNode is used when you want to execute the child only once. If the child is asynchronous,...">RunOnceNode</a> is used when you want to execute the child only once. If the child is asynchronous, we will tick until either SUCCESS or FAILURE is returned.  <a href="../../dd/dbd/class_b_t_1_1_run_once_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d35/class_b_t_1_1_runtime_error.html">RuntimeError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d8c/class_b_t_1_1scoped__demangled__name.html">scoped_demangled_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d26/class_b_t_1_1_script_condition.html">ScriptCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a script, and if the result is true, return SUCCESS, FAILURE otherwise.  <a href="../../da/d26/class_b_t_1_1_script_condition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d0f/class_b_t_1_1_script_node.html">ScriptNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/ddd/class_b_t_1_1_sequence_node.html">SequenceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d9/ddd/class_b_t_1_1_sequence_node.html" title="The SequenceNode is used to tick children in an ordered sequence. If any child returns RUNNING,...">SequenceNode</a> is used to tick children in an ordered sequence. If any child returns RUNNING, previous children will NOT be ticked again.  <a href="../../d9/ddd/class_b_t_1_1_sequence_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d69/class_b_t_1_1_sequence_with_memory.html">SequenceWithMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../de/d69/class_b_t_1_1_sequence_with_memory.html" title="The SequenceWithMemory is used to tick children in an ordered sequence. If any child returns RUNNING,...">SequenceWithMemory</a> is used to tick children in an ordered sequence. If any child returns RUNNING, previous children are not ticked again.  <a href="../../de/d69/class_b_t_1_1_sequence_with_memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d4f/class_b_t_1_1_set_blackboard_node.html">SetBlackboardNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SetBlackboard is action used to store a string into an entry of the <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html" title="The Blackboard is the mechanism used by BehaviorTrees to exchange typed data.">Blackboard</a> specified in "output_key".  <a href="../../d7/d4f/class_b_t_1_1_set_blackboard_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddd/class_b_t_1_1_shared_library.html">SharedLibrary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d73/class_b_t_1_1_signal.html">Signal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da7/class_b_t_1_1_simple_action_node.html">SimpleActionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d7/da7/class_b_t_1_1_simple_action_node.html" title="The SimpleActionNode provides an easy to use SyncActionNode. The user should simply provide a callbac...">SimpleActionNode</a> provides an easy to use <a class="el" href="../../da/d73/class_b_t_1_1_sync_action_node.html" title="The SyncActionNode is an ActionNode that explicitly prevents the status RUNNING and doesn&#39;t require a...">SyncActionNode</a>. The user should simply provide a callback with this signature.  <a href="../../d7/da7/class_b_t_1_1_simple_action_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d49/class_b_t_1_1_simple_condition_node.html">SimpleConditionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dc/d49/class_b_t_1_1_simple_condition_node.html" title="The SimpleConditionNode provides an easy to use ConditionNode. The user should simply provide a callb...">SimpleConditionNode</a> provides an easy to use <a class="el" href="../../dc/dfc/class_b_t_1_1_condition_node.html">ConditionNode</a>. The user should simply provide a callback with this signature.  <a href="../../dc/d49/class_b_t_1_1_simple_condition_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d37/class_b_t_1_1_simple_decorator_node.html">SimpleDecoratorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d3/d37/class_b_t_1_1_simple_decorator_node.html" title="The SimpleDecoratorNode provides an easy to use DecoratorNode. The user should simply provide a callb...">SimpleDecoratorNode</a> provides an easy to use <a class="el" href="../../d1/de7/class_b_t_1_1_decorator_node.html">DecoratorNode</a>. The user should simply provide a callback with this signature.  <a href="../../d3/d37/class_b_t_1_1_simple_decorator_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d33/class_b_t_1_1_sleep_node.html">SleepNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a certain amount of time. Consider also using the decorator &lt;Delay&gt;  <a href="../../d9/d33/class_b_t_1_1_sleep_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/ddb/class_b_t_1_1_sqlite_logger.html">SqliteLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../df/ddb/class_b_t_1_1_sqlite_logger.html" title="The SqliteLogger is a logger that will store the tree and all the status transitions in a SQLite data...">SqliteLogger</a> is a logger that will store the tree and all the status transitions in a SQLite database (single file).  <a href="../../df/ddb/class_b_t_1_1_sqlite_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfa/struct_b_t_1_1_stamped_value.html">StampedValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1f/class_b_t_1_1_stateful_action_node.html">StatefulActionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d0/d1f/class_b_t_1_1_stateful_action_node.html" title="The StatefulActionNode is the preferred way to implement asynchronous Actions. It is actually easier ...">StatefulActionNode</a> is the preferred way to implement asynchronous Actions. It is actually easier to use correctly, when compared with <a class="el" href="../../d2/d61/class_b_t_1_1_threaded_action.html" title="The ThreadedAction executes the tick in a different thread.">ThreadedAction</a>.  <a href="../../d0/d1f/class_b_t_1_1_stateful_action_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dbb/class_b_t_1_1_status_change_logger.html">StatusChangeLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d52/class_b_t_1_1_std_cout_logger.html">StdCoutLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d52/class_b_t_1_1_std_cout_logger.html" title="StdCoutLogger is a very simple logger that displays all the transitions on the console.">StdCoutLogger</a> is a very simple logger that displays all the transitions on the console.  <a href="../../d1/d52/class_b_t_1_1_std_cout_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d34/class_b_t_1_1_sub_tree_node.html">SubTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../df/d34/class_b_t_1_1_sub_tree_node.html" title="The SubTreeNode is a way to wrap an entire Subtree, creating a separated BlackBoard....">SubTreeNode</a> is a way to wrap an entire Subtree, creating a separated BlackBoard. If you want to have data flow through ports, you need to explicitly remap the ports.  <a href="../../df/d34/class_b_t_1_1_sub_tree_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dae/class_b_t_1_1_switch_node.html">SwitchNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d73/class_b_t_1_1_sync_action_node.html">SyncActionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../da/d73/class_b_t_1_1_sync_action_node.html" title="The SyncActionNode is an ActionNode that explicitly prevents the status RUNNING and doesn&#39;t require a...">SyncActionNode</a> is an ActionNode that explicitly prevents the status RUNNING and doesn't require an implementation of <a class="el" href="../../da/d73/class_b_t_1_1_sync_action_node.html#a20556b49ddc39c608018209643fc14d2" title="You don&#39;t need to override this.">halt()</a>.  <a href="../../da/d73/class_b_t_1_1_sync_action_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7f/class_b_t_1_1_test_node.html">TestNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d5/d7f/class_b_t_1_1_test_node.html" title="The TestNode is a Node that can be configure to:">TestNode</a> is a Node that can be configure to:  <a href="../../d5/d7f/class_b_t_1_1_test_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d58/struct_b_t_1_1_test_node_config.html">TestNodeConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d61/class_b_t_1_1_threaded_action.html">ThreadedAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d2/d61/class_b_t_1_1_threaded_action.html" title="The ThreadedAction executes the tick in a different thread.">ThreadedAction</a> executes the tick in a different thread.  <a href="../../d2/d61/class_b_t_1_1_threaded_action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d20/class_b_t_1_1_timeout_node.html">TimeoutNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d4/d20/class_b_t_1_1_timeout_node.html" title="The TimeoutNode will halt() a running child if the latter has been RUNNING longer than a given time....">TimeoutNode</a> will halt() a running child if the latter has been RUNNING longer than a given time. The timeout is in milliseconds and it is passed using the port "msec".  <a href="../../d4/d20/class_b_t_1_1_timeout_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4c/class_b_t_1_1_timer_queue.html">TimerQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d59/struct_b_t_1_1_timestamp.html">Timestamp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used to store a tree. If this object goes out of scope, the tree is destroyed.  <a href="../../d1/d79/class_b_t_1_1_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for Behavior <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html" title="Struct used to store a tree. If this object goes out of scope, the tree is destroyed.">Tree</a> Nodes.  <a href="../../da/d61/class_b_t_1_1_tree_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d6c/struct_b_t_1_1_tree_node_manifest.html">TreeNodeManifest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This information is used mostly by the <a class="el" href="../../d8/d05/class_b_t_1_1_x_m_l_parser.html" title="The XMLParser is a class used to read the model of a BehaviorTree from file or text and instantiate t...">XMLParser</a>.  <a href="../../dc/d6c/struct_b_t_1_1_tree_node_manifest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2b/class_b_t_1_1_tree_observer.html">TreeObserver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d2/d2b/class_b_t_1_1_tree_observer.html" title="The TreeObserver is used to collect statistics about which nodes are executed and their returned stat...">TreeObserver</a> is used to collect statistics about which nodes are executed and their returned status.  <a href="../../d2/d2b/class_b_t_1_1_tree_observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d34/class_b_t_1_1_type_info.html">TypeInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d77/class_b_t_1_1_unset_blackboard_node.html">UnsetBlackboardNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d2f/class_b_t_1_1_wake_up_signal.html">WakeUpSignal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d54/class_b_t_1_1_while_do_else_node.html">WhileDoElseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">WhileDoElse must have exactly 2 or 3 children. It is a REACTIVE node of <a class="el" href="../../d8/d08/class_b_t_1_1_if_then_else_node.html" title="IfThenElseNode must have exactly 2 or 3 children. This node is NOT reactive.">IfThenElseNode</a>.  <a href="../../d7/d54/class_b_t_1_1_while_do_else_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d05/class_b_t_1_1_x_m_l_parser.html">XMLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d8/d05/class_b_t_1_1_x_m_l_parser.html" title="The XMLParser is a class used to read the model of a BehaviorTree from file or text and instantiate t...">XMLParser</a> is a class used to read the model of a BehaviorTree from file or text and instantiate the corresponding tree using the <a class="el" href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html" title="The BehaviorTreeFactory is used to create instances of a TreeNode at run-time.">BehaviorTreeFactory</a>.  <a href="../../d8/d05/class_b_t_1_1_x_m_l_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae592bef580bb9953073171fef1ecf180"><td class="memItemLeft" align="right" valign="top"><a id="ae592bef580bb9953073171fef1ecf180" name="ae592bef580bb9953073171fef1ecf180"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StringView</b> = std::string_view</td></tr>
<tr class="separator:ae592bef580bb9953073171fef1ecf180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139eb34cb9abb2f53e5796e4951572af"><td class="memItemLeft" align="right" valign="top"><a id="a139eb34cb9abb2f53e5796e4951572af" name="a139eb34cb9abb2f53e5796e4951572af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeyValueVector</b> = std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;</td></tr>
<tr class="separator:a139eb34cb9abb2f53e5796e4951572af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed468293f4e7dc7ebbaca1a475526f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ed468293f4e7dc7ebbaca1a475526f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a7ed468293f4e7dc7ebbaca1a475526f3">Expected</a> = nonstd::expected&lt; T, std::string &gt;</td></tr>
<tr class="separator:a7ed468293f4e7dc7ebbaca1a475526f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b78296a8ef18dba3eee791954e01dd"><td class="memItemLeft" align="right" valign="top"><a id="a54b78296a8ef18dba3eee791954e01dd" name="a54b78296a8ef18dba3eee791954e01dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StringConverter</b> = std::function&lt; <a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a>(StringView)&gt;</td></tr>
<tr class="separator:a54b78296a8ef18dba3eee791954e01dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb3cc19456eac7b27dbc5961c56e9cb"><td class="memItemLeft" align="right" valign="top"><a id="a7eb3cc19456eac7b27dbc5961c56e9cb" name="a7eb3cc19456eac7b27dbc5961c56e9cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StringConvertersMap</b> = std::unordered_map&lt; const std::type_info *, StringConverter &gt;</td></tr>
<tr class="separator:a7eb3cc19456eac7b27dbc5961c56e9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e607e156fe3d527866945ff5442664"><td class="memTemplParams" colspan="2"><a id="a29e607e156fe3d527866945ff5442664" name="a29e607e156fe3d527866945ff5442664"></a>
template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a29e607e156fe3d527866945ff5442664"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if</b> = typename std::enable_if&lt; Predicate::value &gt;::type *</td></tr>
<tr class="separator:a29e607e156fe3d527866945ff5442664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79de0dc8900a09d9512eef5fd851376"><td class="memTemplParams" colspan="2"><a id="ac79de0dc8900a09d9512eef5fd851376" name="ac79de0dc8900a09d9512eef5fd851376"></a>
template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:ac79de0dc8900a09d9512eef5fd851376"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_not</b> = typename std::enable_if&lt;!Predicate::value &gt;::type *</td></tr>
<tr class="separator:ac79de0dc8900a09d9512eef5fd851376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e3c5c30d6bff91c95a9184fec5a2d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#ad8e3c5c30d6bff91c95a9184fec5a2d5">Result</a> = <a class="el" href="../../d2/d8d/namespace_b_t.html#a7ed468293f4e7dc7ebbaca1a475526f3">Expected</a>&lt; std::monostate &gt;</td></tr>
<tr class="separator:ad8e3c5c30d6bff91c95a9184fec5a2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee295640b2ab1a31ac19244afc4d1e1"><td class="memItemLeft" align="right" valign="top"><a id="abee295640b2ab1a31ac19244afc4d1e1" name="abee295640b2ab1a31ac19244afc4d1e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PortsList</b> = std::unordered_map&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt;</td></tr>
<tr class="separator:abee295640b2ab1a31ac19244afc4d1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da7af24610dd710149eb670d802f34c"><td class="memItemLeft" align="right" valign="top"><a id="a5da7af24610dd710149eb670d802f34c" name="a5da7af24610dd710149eb670d802f34c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TimePoint</b> = std::chrono::high_resolution_clock::time_point</td></tr>
<tr class="separator:a5da7af24610dd710149eb670d802f34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822e74c9ccb4bf072ea824cd4947195f"><td class="memItemLeft" align="right" valign="top"><a id="a822e74c9ccb4bf072ea824cd4947195f" name="a822e74c9ccb4bf072ea824cd4947195f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Duration</b> = std::chrono::high_resolution_clock::duration</td></tr>
<tr class="separator:a822e74c9ccb4bf072ea824cd4947195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f79fa10250bfc94f2f2d85a3029c300"><td class="memItemLeft" align="right" valign="top"><a id="a6f79fa10250bfc94f2f2d85a3029c300" name="a6f79fa10250bfc94f2f2d85a3029c300"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SerializedTreeStatus</b> = std::vector&lt; std::pair&lt; uint16_t, uint8_t &gt; &gt;</td></tr>
<tr class="separator:a6f79fa10250bfc94f2f2d85a3029c300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3912e0e286d30ab35df23ed44632e4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#ab3912e0e286d30ab35df23ed44632e4f">AnyPtrLocked</a> = <a class="el" href="../../d4/d98/class_b_t_1_1_locked_ptr.html">LockedPtr</a>&lt; <a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a> &gt;</td></tr>
<tr class="separator:ab3912e0e286d30ab35df23ed44632e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92afa24aac8b115778d5a99099b40d5b"><td class="memItemLeft" align="right" valign="top"><a id="a92afa24aac8b115778d5a99099b40d5b" name="a92afa24aac8b115778d5a99099b40d5b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeBuilder</b> = std::function&lt; std::unique_ptr&lt; <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> &gt;(const std::string &amp;, const <a class="el" href="../../dc/d26/struct_b_t_1_1_node_config.html">NodeConfig</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a92afa24aac8b115778d5a99099b40d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The term "Builder" refers to the Builder Pattern (<a href="https://en.wikipedia.org/wiki/Builder_pattern">https://en.wikipedia.org/wiki/Builder_pattern</a>) <br /></td></tr>
<tr class="separator:a92afa24aac8b115778d5a99099b40d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2327d0e317d6d5f756b8d62c8a47aa77"><td class="memTemplParams" colspan="2"><a id="a2327d0e317d6d5f756b8d62c8a47aa77" name="a2327d0e317d6d5f756b8d62c8a47aa77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2327d0e317d6d5f756b8d62c8a47aa77"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SharedQueue</b> = std::shared_ptr&lt; std::deque&lt; T &gt; &gt;</td></tr>
<tr class="separator:a2327d0e317d6d5f756b8d62c8a47aa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe29d81b7453baa0046b0223f21928"><td class="memItemLeft" align="right" valign="top"><a id="a3ffe29d81b7453baa0046b0223f21928" name="a3ffe29d81b7453baa0046b0223f21928"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SerializedTransition</b> = std::array&lt; uint8_t, 12 &gt;</td></tr>
<tr class="separator:a3ffe29d81b7453baa0046b0223f21928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2df96e431683d5655acbfe26026f59"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#aae2df96e431683d5655acbfe26026f59">EnumsTable</a> = std::unordered_map&lt; std::string, int &gt;</td></tr>
<tr class="separator:aae2df96e431683d5655acbfe26026f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5107d1d810e322c8e3cf45196a60a7"><td class="memItemLeft" align="right" valign="top"><a id="acc5107d1d810e322c8e3cf45196a60a7" name="acc5107d1d810e322c8e3cf45196a60a7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EnumsTablePtr</b> = std::shared_ptr&lt; <a class="el" href="../../d2/d8d/namespace_b_t.html#aae2df96e431683d5655acbfe26026f59">EnumsTable</a> &gt;</td></tr>
<tr class="separator:acc5107d1d810e322c8e3cf45196a60a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8f458b42e1d270e692bb992e8d2e0c"><td class="memItemLeft" align="right" valign="top"><a id="a6a8f458b42e1d270e692bb992e8d2e0c" name="a6a8f458b42e1d270e692bb992e8d2e0c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ScriptFunction</b> = std::function&lt; <a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a>(<a class="el" href="../../d0/de8/struct_b_t_1_1_ast_1_1_environment.html">Ast::Environment</a> &amp;env)&gt;</td></tr>
<tr class="separator:a6a8f458b42e1d270e692bb992e8d2e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850220c4f32f14bad4e9a008dcce8216"><td class="memItemLeft" align="right" valign="top"><a id="a850220c4f32f14bad4e9a008dcce8216" name="a850220c4f32f14bad4e9a008dcce8216"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PortsRemapping</b> = std::unordered_map&lt; std::string, std::string &gt;</td></tr>
<tr class="separator:a850220c4f32f14bad4e9a008dcce8216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872aa78173764a2db20696e332177475"><td class="memItemLeft" align="right" valign="top"><a id="a872aa78173764a2db20696e332177475" name="a872aa78173764a2db20696e332177475"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NonPortAttributes</b> = std::unordered_map&lt; std::string, std::string &gt;</td></tr>
<tr class="separator:a872aa78173764a2db20696e332177475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd63366beeee4e47652559ca545f7cc"><td class="memItemLeft" align="right" valign="top"><a id="a6cd63366beeee4e47652559ca545f7cc" name="a6cd63366beeee4e47652559ca545f7cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ScriptingEnumsRegistry</b> = std::unordered_map&lt; std::string, int &gt;</td></tr>
<tr class="separator:a6cd63366beeee4e47652559ca545f7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5ac2910c971f25a17045cb181ed7c5"><td class="memItemLeft" align="right" valign="top"><a id="a8f5ac2910c971f25a17045cb181ed7c5" name="a8f5ac2910c971f25a17045cb181ed7c5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeConfiguration</b> = <a class="el" href="../../dc/d26/struct_b_t_1_1_node_config.html">NodeConfig</a></td></tr>
<tr class="separator:a8f5ac2910c971f25a17045cb181ed7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a86a6454c13791311dface943d837363e"><td class="memItemLeft" align="right" valign="top"><a id="a86a6454c13791311dface943d837363e" name="a86a6454c13791311dface943d837363e"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a86a6454c13791311dface943d837363e">NodeType</a> { <br />
&#160;&#160;<b>UNDEFINED</b> = 0
, <b>ACTION</b>
, <b>CONDITION</b>
, <b>CONTROL</b>
, <br />
&#160;&#160;<b>DECORATOR</b>
, <b>SUBTREE</b>
<br />
 }</td></tr>
<tr class="memdesc:a86a6454c13791311dface943d837363e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the possible types of nodes. <br /></td></tr>
<tr class="separator:a86a6454c13791311dface943d837363e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1414a8362678cd4081eeb30b72845b4e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">NodeStatus</a> { <br />
&#160;&#160;<b>IDLE</b> = 0
, <b>RUNNING</b> = 1
, <b>SUCCESS</b> = 2
, <b>FAILURE</b> = 3
, <br />
&#160;&#160;<b>SKIPPED</b> = 4
<br />
 }</td></tr>
<tr class="separator:a1414a8362678cd4081eeb30b72845b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa2e558c43f8ef869484be868eac159"><td class="memItemLeft" align="right" valign="top"><a id="a3fa2e558c43f8ef869484be868eac159" name="a3fa2e558c43f8ef869484be868eac159"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>PortDirection</b> { <b>INPUT</b>
, <b>OUTPUT</b>
, <b>INOUT</b>
 }</td></tr>
<tr class="separator:a3fa2e558c43f8ef869484be868eac159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48001cdc54ea73b84f32a04197b10984"><td class="memItemLeft" align="right" valign="top"><a id="a48001cdc54ea73b84f32a04197b10984" name="a48001cdc54ea73b84f32a04197b10984"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>TimestampType</b> { <b>absolute</b>
, <b>relative</b>
 }</td></tr>
<tr class="separator:a48001cdc54ea73b84f32a04197b10984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a300ae4685c319c4027015e7e031228"><td class="memItemLeft" align="right" valign="top"><a id="a9a300ae4685c319c4027015e7e031228" name="a9a300ae4685c319c4027015e7e031228"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>PreCond</b> { <br />
&#160;&#160;<b>FAILURE_IF</b> = 0
, <b>SUCCESS_IF</b>
, <b>SKIP_IF</b>
, <b>WHILE_TRUE</b>
, <br />
&#160;&#160;<b>COUNT_</b>
<br />
 }</td></tr>
<tr class="separator:a9a300ae4685c319c4027015e7e031228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7928f534d107f01bf32885641f27c8"><td class="memItemLeft" align="right" valign="top"><a id="a9d7928f534d107f01bf32885641f27c8" name="a9d7928f534d107f01bf32885641f27c8"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>PostCond</b> { <br />
&#160;&#160;<b>ON_HALTED</b> = 0
, <b>ON_FAILURE</b>
, <b>ON_SUCCESS</b>
, <b>ALWAYS</b>
, <br />
&#160;&#160;<b>COUNT_</b>
<br />
 }</td></tr>
<tr class="separator:a9d7928f534d107f01bf32885641f27c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a895a8f42f65f1a9bb8d054b215cbc815"><td class="memItemLeft" align="right" valign="top"><a id="a895a8f42f65f1a9bb8d054b215cbc815" name="a895a8f42f65f1a9bb8d054b215cbc815"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isStatusActive</b> (const <a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">NodeStatus</a> &amp;status)</td></tr>
<tr class="separator:a895a8f42f65f1a9bb8d054b215cbc815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b1535ea637f8af8f4e97e8dd95f27b"><td class="memItemLeft" align="right" valign="top"><a id="aa8b1535ea637f8af8f4e97e8dd95f27b" name="aa8b1535ea637f8af8f4e97e8dd95f27b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isStatusCompleted</b> (const <a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">NodeStatus</a> &amp;status)</td></tr>
<tr class="separator:aa8b1535ea637f8af8f4e97e8dd95f27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2905e7415f8e1670b6b53717c79bf226"><td class="memItemLeft" align="right" valign="top"><a id="a2905e7415f8e1670b6b53717c79bf226" name="a2905e7415f8e1670b6b53717c79bf226"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StartWith</b> (StringView str, StringView prefix)</td></tr>
<tr class="separator:a2905e7415f8e1670b6b53717c79bf226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f791561821a74c55d37161066b1f92"><td class="memItemLeft" align="right" valign="top"><a id="a72f791561821a74c55d37161066b1f92" name="a72f791561821a74c55d37161066b1f92"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StartWith</b> (StringView str, char prefix)</td></tr>
<tr class="separator:a72f791561821a74c55d37161066b1f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183200576f5fa139ae3359abbe8ef1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a183200576f5fa139ae3359abbe8ef1c4">convertFromJSON</a> (StringView json_text, std::type_index type)</td></tr>
<tr class="memdesc:a183200576f5fa139ae3359abbe8ef1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convertFromJSON will parse a json string and use <a class="el" href="../../d0/d64/class_b_t_1_1_json_exporter.html">JsonExporter</a> to convert its content to a given type. It will work only if the type was previously registered. May throw if it fails.  <br /></td></tr>
<tr class="separator:a183200576f5fa139ae3359abbe8ef1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1eef4943ac07de099ec403979c488f"><td class="memTemplParams" colspan="2"><a id="a6f1eef4943ac07de099ec403979c488f" name="a6f1eef4943ac07de099ec403979c488f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f1eef4943ac07de099ec403979c488f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromJSON</b> (StringView str)</td></tr>
<tr class="memdesc:a6f1eef4943ac07de099ec403979c488f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the non template version, but with automatic casting. <br /></td></tr>
<tr class="separator:a6f1eef4943ac07de099ec403979c488f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf200f50db2b15eea2e20e6a068a0d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afaf200f50db2b15eea2e20e6a068a0d2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#afaf200f50db2b15eea2e20e6a068a0d2">convertFromString</a> (StringView str)</td></tr>
<tr class="separator:afaf200f50db2b15eea2e20e6a068a0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49e61014591c958e9ef3a0699aa542a"><td class="memItemLeft" align="right" valign="top"><a id="ac49e61014591c958e9ef3a0699aa542a" name="ac49e61014591c958e9ef3a0699aa542a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac49e61014591c958e9ef3a0699aa542a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; std::string &gt;</b> (StringView str)</td></tr>
<tr class="separator:ac49e61014591c958e9ef3a0699aa542a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fc4be3c96acdd6511c307af68bdcb6"><td class="memItemLeft" align="right" valign="top"><a id="a21fc4be3c96acdd6511c307af68bdcb6" name="a21fc4be3c96acdd6511c307af68bdcb6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a21fc4be3c96acdd6511c307af68bdcb6"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; const char * &gt;</b> (StringView str)</td></tr>
<tr class="separator:a21fc4be3c96acdd6511c307af68bdcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67906990475a51a3ad337d1e0c5e2fd6"><td class="memItemLeft" align="right" valign="top"><a id="a67906990475a51a3ad337d1e0c5e2fd6" name="a67906990475a51a3ad337d1e0c5e2fd6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a67906990475a51a3ad337d1e0c5e2fd6"><td class="memTemplItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; int8_t &gt;</b> (StringView str)</td></tr>
<tr class="separator:a67906990475a51a3ad337d1e0c5e2fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a29b21ff87fcfe705cbc95707a676d0"><td class="memItemLeft" align="right" valign="top"><a id="a2a29b21ff87fcfe705cbc95707a676d0" name="a2a29b21ff87fcfe705cbc95707a676d0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2a29b21ff87fcfe705cbc95707a676d0"><td class="memTemplItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; int16_t &gt;</b> (StringView str)</td></tr>
<tr class="separator:a2a29b21ff87fcfe705cbc95707a676d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3fa8e599830b0f807eae2fc883b8cd"><td class="memItemLeft" align="right" valign="top"><a id="a7b3fa8e599830b0f807eae2fc883b8cd" name="a7b3fa8e599830b0f807eae2fc883b8cd"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7b3fa8e599830b0f807eae2fc883b8cd"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; int32_t &gt;</b> (StringView str)</td></tr>
<tr class="separator:a7b3fa8e599830b0f807eae2fc883b8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8319b5e316fe3ced55fc6c466d1b8a0b"><td class="memItemLeft" align="right" valign="top"><a id="a8319b5e316fe3ced55fc6c466d1b8a0b" name="a8319b5e316fe3ced55fc6c466d1b8a0b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8319b5e316fe3ced55fc6c466d1b8a0b"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; int64_t &gt;</b> (StringView str)</td></tr>
<tr class="separator:a8319b5e316fe3ced55fc6c466d1b8a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653ac48c9035964446cb4eae8ae53c3b"><td class="memItemLeft" align="right" valign="top"><a id="a653ac48c9035964446cb4eae8ae53c3b" name="a653ac48c9035964446cb4eae8ae53c3b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a653ac48c9035964446cb4eae8ae53c3b"><td class="memTemplItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; uint8_t &gt;</b> (StringView str)</td></tr>
<tr class="separator:a653ac48c9035964446cb4eae8ae53c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53120a431fa04a79f598247795dd140"><td class="memItemLeft" align="right" valign="top"><a id="ac53120a431fa04a79f598247795dd140" name="ac53120a431fa04a79f598247795dd140"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac53120a431fa04a79f598247795dd140"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; uint16_t &gt;</b> (StringView str)</td></tr>
<tr class="separator:ac53120a431fa04a79f598247795dd140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade99d895828270dbf2549d363576b5aa"><td class="memItemLeft" align="right" valign="top"><a id="ade99d895828270dbf2549d363576b5aa" name="ade99d895828270dbf2549d363576b5aa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ade99d895828270dbf2549d363576b5aa"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; uint32_t &gt;</b> (StringView str)</td></tr>
<tr class="separator:ade99d895828270dbf2549d363576b5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8f102372a2c61122c42cf94f9daf80"><td class="memItemLeft" align="right" valign="top"><a id="a4f8f102372a2c61122c42cf94f9daf80" name="a4f8f102372a2c61122c42cf94f9daf80"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4f8f102372a2c61122c42cf94f9daf80"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; uint64_t &gt;</b> (StringView str)</td></tr>
<tr class="separator:a4f8f102372a2c61122c42cf94f9daf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf10b95d4966d669187730d613703e0"><td class="memItemLeft" align="right" valign="top"><a id="abdf10b95d4966d669187730d613703e0" name="abdf10b95d4966d669187730d613703e0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abdf10b95d4966d669187730d613703e0"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; float &gt;</b> (StringView str)</td></tr>
<tr class="separator:abdf10b95d4966d669187730d613703e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae8d75f5737e98269534175b0f518e5"><td class="memItemLeft" align="right" valign="top"><a id="a6ae8d75f5737e98269534175b0f518e5" name="a6ae8d75f5737e98269534175b0f518e5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6ae8d75f5737e98269534175b0f518e5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; double &gt;</b> (StringView str)</td></tr>
<tr class="separator:a6ae8d75f5737e98269534175b0f518e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf14b96cfc38e30d65755d7ba1a032"><td class="memItemLeft" align="right" valign="top"><a id="aaabf14b96cfc38e30d65755d7ba1a032" name="aaabf14b96cfc38e30d65755d7ba1a032"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aaabf14b96cfc38e30d65755d7ba1a032"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; std::vector&lt; int &gt; &gt;</b> (StringView str)</td></tr>
<tr class="separator:aaabf14b96cfc38e30d65755d7ba1a032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e07fbfb98b076a108b64cec29f7590"><td class="memItemLeft" align="right" valign="top"><a id="ab3e07fbfb98b076a108b64cec29f7590" name="ab3e07fbfb98b076a108b64cec29f7590"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab3e07fbfb98b076a108b64cec29f7590"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; std::vector&lt; double &gt; &gt;</b> (StringView str)</td></tr>
<tr class="separator:ab3e07fbfb98b076a108b64cec29f7590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac949efd9960b81d169040f01c594282a"><td class="memItemLeft" align="right" valign="top"><a id="ac949efd9960b81d169040f01c594282a" name="ac949efd9960b81d169040f01c594282a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac949efd9960b81d169040f01c594282a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; std::vector&lt; std::string &gt; &gt;</b> (StringView str)</td></tr>
<tr class="separator:ac949efd9960b81d169040f01c594282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78384be19d005fe052b5bf656709231"><td class="memItemLeft" align="right" valign="top"><a id="ac78384be19d005fe052b5bf656709231" name="ac78384be19d005fe052b5bf656709231"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac78384be19d005fe052b5bf656709231"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; bool &gt;</b> (StringView str)</td></tr>
<tr class="separator:ac78384be19d005fe052b5bf656709231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17a3e7ce16ade16015356669a7ac375"><td class="memItemLeft" align="right" valign="top"><a id="aa17a3e7ce16ade16015356669a7ac375" name="aa17a3e7ce16ade16015356669a7ac375"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa17a3e7ce16ade16015356669a7ac375"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">NodeStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; NodeStatus &gt;</b> (StringView str)</td></tr>
<tr class="separator:aa17a3e7ce16ade16015356669a7ac375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6945853d5f00d1beef92fec3d4991805"><td class="memItemLeft" align="right" valign="top"><a id="a6945853d5f00d1beef92fec3d4991805" name="a6945853d5f00d1beef92fec3d4991805"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6945853d5f00d1beef92fec3d4991805"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/d8d/namespace_b_t.html#a86a6454c13791311dface943d837363e">NodeType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; NodeType &gt;</b> (StringView str)</td></tr>
<tr class="separator:a6945853d5f00d1beef92fec3d4991805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19097838325cac956341ba040c717871"><td class="memItemLeft" align="right" valign="top"><a id="a19097838325cac956341ba040c717871" name="a19097838325cac956341ba040c717871"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a19097838325cac956341ba040c717871"><td class="memTemplItemLeft" align="right" valign="top">PortDirection&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; PortDirection &gt;</b> (StringView str)</td></tr>
<tr class="separator:a19097838325cac956341ba040c717871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412d7cbd3c2cb66c5e3e082af53c4caa"><td class="memTemplParams" colspan="2"><a id="a412d7cbd3c2cb66c5e3e082af53c4caa" name="a412d7cbd3c2cb66c5e3e082af53c4caa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a412d7cbd3c2cb66c5e3e082af53c4caa"><td class="memTemplItemLeft" align="right" valign="top">StringConverter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetAnyFromStringFunctor</b> ()</td></tr>
<tr class="separator:a412d7cbd3c2cb66c5e3e082af53c4caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848a5784ffcb65908e161aeb608756dc"><td class="memItemLeft" align="right" valign="top"><a id="a848a5784ffcb65908e161aeb608756dc" name="a848a5784ffcb65908e161aeb608756dc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a848a5784ffcb65908e161aeb608756dc"><td class="memTemplItemLeft" align="right" valign="top">StringConverter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetAnyFromStringFunctor&lt; void &gt;</b> ()</td></tr>
<tr class="separator:a848a5784ffcb65908e161aeb608756dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e76c01342f36e39f074fdd99f3ee508"><td class="memTemplParams" colspan="2"><a id="a5e76c01342f36e39f074fdd99f3ee508" name="a5e76c01342f36e39f074fdd99f3ee508"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e76c01342f36e39f074fdd99f3ee508"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsConvertibleToString</b> ()</td></tr>
<tr class="separator:a5e76c01342f36e39f074fdd99f3ee508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b81d74425dabbe4b1a612df39c1dbd"><td class="memItemLeft" align="right" valign="top"><a id="aa2b81d74425dabbe4b1a612df39c1dbd" name="aa2b81d74425dabbe4b1a612df39c1dbd"></a>
<a class="el" href="../../d2/d8d/namespace_b_t.html#a7ed468293f4e7dc7ebbaca1a475526f3">Expected</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>toJsonString</b> (const <a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a> &amp;value)</td></tr>
<tr class="separator:aa2b81d74425dabbe4b1a612df39c1dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc7285d759ccee669271f9884941cf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdc7285d759ccee669271f9884941cf9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#acdc7285d759ccee669271f9884941cf9">toStr</a> (const T &amp;value)</td></tr>
<tr class="memdesc:acdc7285d759ccee669271f9884941cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">toStr is the reverse operation of convertFromString.  <br /></td></tr>
<tr class="separator:acdc7285d759ccee669271f9884941cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163165498ebf9a162e586422230c428c"><td class="memItemLeft" align="right" valign="top"><a id="a163165498ebf9a162e586422230c428c" name="a163165498ebf9a162e586422230c428c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a163165498ebf9a162e586422230c428c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toStr&lt; bool &gt;</b> (const bool &amp;value)</td></tr>
<tr class="separator:a163165498ebf9a162e586422230c428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eca7e5f9e9afef7cd46ed06b48783b7"><td class="memItemLeft" align="right" valign="top"><a id="a1eca7e5f9e9afef7cd46ed06b48783b7" name="a1eca7e5f9e9afef7cd46ed06b48783b7"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1eca7e5f9e9afef7cd46ed06b48783b7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toStr&lt; std::string &gt;</b> (const std::string &amp;value)</td></tr>
<tr class="separator:a1eca7e5f9e9afef7cd46ed06b48783b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b044f70ced85a73f6cc70edc7ea351"><td class="memItemLeft" align="right" valign="top"><a id="a28b044f70ced85a73f6cc70edc7ea351" name="a28b044f70ced85a73f6cc70edc7ea351"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a28b044f70ced85a73f6cc70edc7ea351"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toStr&lt; BT::NodeStatus &gt;</b> (const <a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">BT::NodeStatus</a> &amp;status)</td></tr>
<tr class="separator:a28b044f70ced85a73f6cc70edc7ea351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b08b9acce3233964741ac39102abda"><td class="memItemLeft" align="right" valign="top"><a id="a59b08b9acce3233964741ac39102abda" name="a59b08b9acce3233964741ac39102abda"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStr</b> (<a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">BT::NodeStatus</a> status, bool colored)</td></tr>
<tr class="memdesc:a59b08b9acce3233964741ac39102abda"><td class="mdescLeft">&#160;</td><td class="mdescRight">toStr converts NodeStatus to string. Optionally colored. <br /></td></tr>
<tr class="separator:a59b08b9acce3233964741ac39102abda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88937e2c0f5f5375b47f77af5fa44c8d"><td class="memItemLeft" align="right" valign="top"><a id="a88937e2c0f5f5375b47f77af5fa44c8d" name="a88937e2c0f5f5375b47f77af5fa44c8d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">BT::NodeStatus</a> &amp;status)</td></tr>
<tr class="separator:a88937e2c0f5f5375b47f77af5fa44c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afc35bd7ee91fcb5f97e88e8e056422"><td class="memItemLeft" align="right" valign="top"><a id="a6afc35bd7ee91fcb5f97e88e8e056422" name="a6afc35bd7ee91fcb5f97e88e8e056422"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6afc35bd7ee91fcb5f97e88e8e056422"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toStr&lt; BT::NodeType &gt;</b> (const <a class="el" href="../../d2/d8d/namespace_b_t.html#a86a6454c13791311dface943d837363e">BT::NodeType</a> &amp;type)</td></tr>
<tr class="separator:a6afc35bd7ee91fcb5f97e88e8e056422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c2ed987bf099240156782c77c08181"><td class="memItemLeft" align="right" valign="top"><a id="a23c2ed987bf099240156782c77c08181" name="a23c2ed987bf099240156782c77c08181"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="../../d2/d8d/namespace_b_t.html#a86a6454c13791311dface943d837363e">BT::NodeType</a> &amp;type)</td></tr>
<tr class="separator:a23c2ed987bf099240156782c77c08181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8a6954a960d464b83ed1e24fedcb5b"><td class="memItemLeft" align="right" valign="top"><a id="adc8a6954a960d464b83ed1e24fedcb5b" name="adc8a6954a960d464b83ed1e24fedcb5b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc8a6954a960d464b83ed1e24fedcb5b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toStr&lt; BT::PortDirection &gt;</b> (const BT::PortDirection &amp;direction)</td></tr>
<tr class="separator:adc8a6954a960d464b83ed1e24fedcb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3255cff49a3368a377a36559b0b11a65"><td class="memItemLeft" align="right" valign="top"><a id="a3255cff49a3368a377a36559b0b11a65" name="a3255cff49a3368a377a36559b0b11a65"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const BT::PortDirection &amp;type)</td></tr>
<tr class="separator:a3255cff49a3368a377a36559b0b11a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d4648ebc4bd6c00cb844cbaad5599a"><td class="memItemLeft" align="right" valign="top"><a id="ab8d4648ebc4bd6c00cb844cbaad5599a" name="ab8d4648ebc4bd6c00cb844cbaad5599a"></a>
std::vector&lt; StringView &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>splitString</b> (const StringView &amp;strToSplit, char delimeter)</td></tr>
<tr class="separator:ab8d4648ebc4bd6c00cb844cbaad5599a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7287dd25b4aa7c2bb77aba53b9e82b9"><td class="memItemLeft" align="right" valign="top"><a id="aa7287dd25b4aa7c2bb77aba53b9e82b9" name="aa7287dd25b4aa7c2bb77aba53b9e82b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsAllowedPortName</b> (StringView str)</td></tr>
<tr class="separator:aa7287dd25b4aa7c2bb77aba53b9e82b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c47a72ad0a540ad6b978d31fe8275"><td class="memItemLeft" align="right" valign="top"><a id="a074c47a72ad0a540ad6b978d31fe8275" name="a074c47a72ad0a540ad6b978d31fe8275"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReservedAttribute</b> (StringView str)</td></tr>
<tr class="separator:a074c47a72ad0a540ad6b978d31fe8275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198312e3776d7af945108b79e9296df9"><td class="memTemplParams" colspan="2"><a id="a198312e3776d7af945108b79e9296df9" name="a198312e3776d7af945108b79e9296df9"></a>
template&lt;typename T  = AnyTypeAllowed&gt; </td></tr>
<tr class="memitem:a198312e3776d7af945108b79e9296df9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreatePort</b> (PortDirection direction, StringView name, StringView description={})</td></tr>
<tr class="separator:a198312e3776d7af945108b79e9296df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d63b9f7eba8a9a98322107ef8e0ae3d"><td class="memTemplParams" colspan="2">template&lt;typename T  = AnyTypeAllowed&gt; </td></tr>
<tr class="memitem:a9d63b9f7eba8a9a98322107ef8e0ae3d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a9d63b9f7eba8a9a98322107ef8e0ae3d">InputPort</a> (StringView name, StringView description={})</td></tr>
<tr class="separator:a9d63b9f7eba8a9a98322107ef8e0ae3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac171179c71fc0def23cf28e36b8ee2"><td class="memTemplParams" colspan="2">template&lt;typename T  = AnyTypeAllowed&gt; </td></tr>
<tr class="memitem:a8ac171179c71fc0def23cf28e36b8ee2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a8ac171179c71fc0def23cf28e36b8ee2">OutputPort</a> (StringView name, StringView description={})</td></tr>
<tr class="separator:a8ac171179c71fc0def23cf28e36b8ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13321f9dceb6909198966973042a13a1"><td class="memTemplParams" colspan="2">template&lt;typename T  = AnyTypeAllowed&gt; </td></tr>
<tr class="memitem:a13321f9dceb6909198966973042a13a1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a13321f9dceb6909198966973042a13a1">BidirectionalPort</a> (StringView name, StringView description={})</td></tr>
<tr class="separator:a13321f9dceb6909198966973042a13a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8794519d3bc2203f70a65b38f9e37a3c"><td class="memTemplParams" colspan="2">template&lt;typename T  = AnyTypeAllowed, typename DefaultT  = T&gt; </td></tr>
<tr class="memitem:a8794519d3bc2203f70a65b38f9e37a3c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a8794519d3bc2203f70a65b38f9e37a3c">InputPort</a> (StringView name, const DefaultT &amp;default_value, StringView description)</td></tr>
<tr class="separator:a8794519d3bc2203f70a65b38f9e37a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5246156c75012e4106eb05bc9c3cf47"><td class="memTemplParams" colspan="2">template&lt;typename T  = AnyTypeAllowed, typename DefaultT  = T&gt; </td></tr>
<tr class="memitem:aa5246156c75012e4106eb05bc9c3cf47"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#aa5246156c75012e4106eb05bc9c3cf47">BidirectionalPort</a> (StringView name, const DefaultT &amp;default_value, StringView description)</td></tr>
<tr class="separator:aa5246156c75012e4106eb05bc9c3cf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533a06e2f82bd5d915194dcb696f444c"><td class="memTemplParams" colspan="2">template&lt;typename T  = AnyTypeAllowed&gt; </td></tr>
<tr class="memitem:a533a06e2f82bd5d915194dcb696f444c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a533a06e2f82bd5d915194dcb696f444c">OutputPort</a> (StringView name, StringView default_value, StringView description)</td></tr>
<tr class="separator:a533a06e2f82bd5d915194dcb696f444c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3a51824e0ce32e6a96e41b7607fde8"><td class="memTemplParams" colspan="2"><a id="adc3a51824e0ce32e6a96e41b7607fde8" name="adc3a51824e0ce32e6a96e41b7607fde8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc3a51824e0ce32e6a96e41b7607fde8"><td class="memTemplItemLeft" align="right" valign="top">PortsList&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getProvidedPorts</b> (enable_if&lt; <a class="el" href="../../d0/d56/struct_b_t_1_1has__static__method__provided_ports.html">has_static_method_providedPorts</a>&lt; T &gt; &gt;=nullptr)</td></tr>
<tr class="separator:adc3a51824e0ce32e6a96e41b7607fde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e161569ffc0ac3be7deeb1b637cc5c"><td class="memItemLeft" align="right" valign="top"><a id="a33e161569ffc0ac3be7deeb1b637cc5c" name="a33e161569ffc0ac3be7deeb1b637cc5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyRecursiveVisitor</b> (const <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> *root_node, const std::function&lt; void(const <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> *)&gt; &amp;visitor)</td></tr>
<tr class="separator:a33e161569ffc0ac3be7deeb1b637cc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cde2e0bcb2adcd0ca50325d59294b8d"><td class="memItemLeft" align="right" valign="top"><a id="a3cde2e0bcb2adcd0ca50325d59294b8d" name="a3cde2e0bcb2adcd0ca50325d59294b8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyRecursiveVisitor</b> (<a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> *root_node, const std::function&lt; void(<a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> *)&gt; &amp;visitor)</td></tr>
<tr class="separator:a3cde2e0bcb2adcd0ca50325d59294b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fc68e6864ea125011a4ab64e9d6dc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a81fc68e6864ea125011a4ab64e9d6dc3">printTreeRecursively</a> (const <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> *root_node, std::ostream &amp;stream=std::cout)</td></tr>
<tr class="separator:a81fc68e6864ea125011a4ab64e9d6dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa260ec6d0ad8a20a2beff083a470d6ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#aa260ec6d0ad8a20a2beff083a470d6ce">buildSerializedStatusSnapshot</a> (const <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> *root_node, SerializedTreeStatus &amp;serialized_buffer)</td></tr>
<tr class="memdesc:aa260ec6d0ad8a20a2beff083a470d6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">buildSerializedStatusSnapshot can be used to create a buffer that can be stored (or sent to a client application) to know the status of all the nodes of a tree. It is not "human readable".  <br /></td></tr>
<tr class="separator:aa260ec6d0ad8a20a2beff083a470d6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bda3dd22bdb1c2aaa354a610e25ac9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8bda3dd22bdb1c2aaa354a610e25ac9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/d8d/namespace_b_t.html#a86a6454c13791311dface943d837363e">NodeType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#aa8bda3dd22bdb1c2aaa354a610e25ac9">getType</a> ()</td></tr>
<tr class="separator:aa8bda3dd22bdb1c2aaa354a610e25ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27a7749d667ae7470c06ad773abcbc0"><td class="memItemLeft" align="right" valign="top"><a id="ae27a7749d667ae7470c06ad773abcbc0" name="ae27a7749d667ae7470c06ad773abcbc0"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>LibraryVersionString</b> ()</td></tr>
<tr class="separator:ae27a7749d667ae7470c06ad773abcbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785ee2f0443d967d22354c8388510cac"><td class="memItemLeft" align="right" valign="top"><a id="a785ee2f0443d967d22354c8388510cac" name="a785ee2f0443d967d22354c8388510cac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>LibraryVersionNumber</b> ()</td></tr>
<tr class="separator:a785ee2f0443d967d22354c8388510cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9700fbeea6af84efe32e9f22bc45d8e2"><td class="memItemLeft" align="right" valign="top"><a id="a9700fbeea6af84efe32e9f22bc45d8e2" name="a9700fbeea6af84efe32e9f22bc45d8e2"></a>
nlohmann::json&#160;</td><td class="memItemRight" valign="bottom"><b>ExportBlackboardToJSON</b> (const <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html">Blackboard</a> &amp;blackboard)</td></tr>
<tr class="memdesc:a9700fbeea6af84efe32e9f22bc45d8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ExportBlackboardToJSON will create a JSON that contains the current values of the blackboard. Complex types must be registered with JsonExporter::get() <br /></td></tr>
<tr class="separator:a9700fbeea6af84efe32e9f22bc45d8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b8bbf4a1f09391295076701c1457e4"><td class="memItemLeft" align="right" valign="top"><a id="a93b8bbf4a1f09391295076701c1457e4" name="a93b8bbf4a1f09391295076701c1457e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ImportBlackboardFromJSON</b> (const nlohmann::json &amp;json, <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html">Blackboard</a> &amp;blackboard)</td></tr>
<tr class="memdesc:a93b8bbf4a1f09391295076701c1457e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ImportBlackboardFromJSON will append elements to the blackboard, using the values parsed from the JSON file created using ExportBlackboardToJSON. Complex types must be registered with JsonExporter::get() <br /></td></tr>
<tr class="separator:a93b8bbf4a1f09391295076701c1457e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3862f73f14fa99fbb2d0eb5fdf9c5e30"><td class="memTemplParams" colspan="2"><a id="a3862f73f14fa99fbb2d0eb5fdf9c5e30" name="a3862f73f14fa99fbb2d0eb5fdf9c5e30"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a3862f73f14fa99fbb2d0eb5fdf9c5e30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/d8d/namespace_b_t.html#a92afa24aac8b115778d5a99099b40d5b">NodeBuilder</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateBuilder</b> (Args... args)</td></tr>
<tr class="separator:a3862f73f14fa99fbb2d0eb5fdf9c5e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cec669ecee4c2fab0279fa9eed9a33"><td class="memTemplParams" colspan="2"><a id="a69cec669ecee4c2fab0279fa9eed9a33" name="a69cec669ecee4c2fab0279fa9eed9a33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69cec669ecee4c2fab0279fa9eed9a33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d6c/struct_b_t_1_1_tree_node_manifest.html">TreeNodeManifest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateManifest</b> (const std::string &amp;ID, PortsList portlist=getProvidedPorts&lt; T &gt;())</td></tr>
<tr class="separator:a69cec669ecee4c2fab0279fa9eed9a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01a46e6b15dc90bfcd62abf8179787c"><td class="memItemLeft" align="right" valign="top"><a id="ab01a46e6b15dc90bfcd62abf8179787c" name="ab01a46e6b15dc90bfcd62abf8179787c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>WildcardMatch</b> (const std::string &amp;str, StringView filter)</td></tr>
<tr class="separator:ab01a46e6b15dc90bfcd62abf8179787c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c2a1676d84ad1a9b3a809c7c8e8fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#ae1c2a1676d84ad1a9b3a809c7c8e8fdb">BlackboardClone</a> (const <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html">Blackboard</a> &amp;src, <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html">Blackboard</a> &amp;dst)</td></tr>
<tr class="memdesc:ae1c2a1676d84ad1a9b3a809c7c8e8fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">BlackboardClone make a copy of the content of the blackboard.  <br /></td></tr>
<tr class="separator:ae1c2a1676d84ad1a9b3a809c7c8e8fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d3de37134ad6c26809809a99c85cd1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Blackboard::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a39d3de37134ad6c26809809a99c85cd1">BlackboardBackup</a> (const <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">BT::Tree</a> &amp;tree)</td></tr>
<tr class="memdesc:a39d3de37134ad6c26809809a99c85cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">BlackboardBackup uses <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html#afd93b989bbb7add02e649a039c0c0b5e" title="cloneInto copies the values of the entries into another blackboard. Known limitations:">Blackboard::cloneInto</a> to backup all the blackboards of the tree.  <br /></td></tr>
<tr class="separator:a39d3de37134ad6c26809809a99c85cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd0bac756271d4c997ed0a3d67067c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a9fd0bac756271d4c997ed0a3d67067c1">BlackboardRestore</a> (const std::vector&lt; Blackboard::Ptr &gt; &amp;backup, <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">BT::Tree</a> &amp;tree)</td></tr>
<tr class="memdesc:a9fd0bac756271d4c997ed0a3d67067c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">BlackboardRestore uses <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html#afd93b989bbb7add02e649a039c0c0b5e" title="cloneInto copies the values of the entries into another blackboard. Known limitations:">Blackboard::cloneInto</a> to restore all the blackboards of the tree.  <br /></td></tr>
<tr class="separator:a9fd0bac756271d4c997ed0a3d67067c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02848b586dc8265d5d51be939401626d"><td class="memItemLeft" align="right" valign="top"><a id="a02848b586dc8265d5d51be939401626d" name="a02848b586dc8265d5d51be939401626d"></a>
nlohmann::json&#160;</td><td class="memItemRight" valign="bottom"><b>ExportTreeToJSON</b> (const <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">BT::Tree</a> &amp;tree)</td></tr>
<tr class="memdesc:a02848b586dc8265d5d51be939401626d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ExportTreeToJSON it calls ExportBlackboardToJSON for all the blackboards in the tree. <br /></td></tr>
<tr class="separator:a02848b586dc8265d5d51be939401626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47af04695aeb786b3c2ec2267f5bf02b"><td class="memItemLeft" align="right" valign="top"><a id="a47af04695aeb786b3c2ec2267f5bf02b" name="a47af04695aeb786b3c2ec2267f5bf02b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ImportTreeFromJSON</b> (const nlohmann::json &amp;json, <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">BT::Tree</a> &amp;tree)</td></tr>
<tr class="memdesc:a47af04695aeb786b3c2ec2267f5bf02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ImportTreeFromJSON it calls ImportBlackboardFromJSON for all the blackboards in the tree. <br /></td></tr>
<tr class="separator:a47af04695aeb786b3c2ec2267f5bf02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64104be44e52338be65481ba1ca4ab7"><td class="memItemLeft" align="right" valign="top"><a id="ad64104be44e52338be65481ba1ca4ab7" name="ad64104be44e52338be65481ba1ca4ab7"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad64104be44e52338be65481ba1ca4ab7"><td class="memTemplItemLeft" align="right" valign="top">SharedQueue&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; SharedQueue&lt; int &gt; &gt;</b> (StringView str)</td></tr>
<tr class="separator:ad64104be44e52338be65481ba1ca4ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127ad807c59bc9c355e90847ed49ab53"><td class="memItemLeft" align="right" valign="top"><a id="a127ad807c59bc9c355e90847ed49ab53" name="a127ad807c59bc9c355e90847ed49ab53"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a127ad807c59bc9c355e90847ed49ab53"><td class="memTemplItemLeft" align="right" valign="top">SharedQueue&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; SharedQueue&lt; bool &gt; &gt;</b> (StringView str)</td></tr>
<tr class="separator:a127ad807c59bc9c355e90847ed49ab53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab428b2435b4f6f6517632983cf85d417"><td class="memItemLeft" align="right" valign="top"><a id="ab428b2435b4f6f6517632983cf85d417" name="ab428b2435b4f6f6517632983cf85d417"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab428b2435b4f6f6517632983cf85d417"><td class="memTemplItemLeft" align="right" valign="top">SharedQueue&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; SharedQueue&lt; double &gt; &gt;</b> (StringView str)</td></tr>
<tr class="separator:ab428b2435b4f6f6517632983cf85d417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce3fa58310d6acb433d74b51885cdc8"><td class="memItemLeft" align="right" valign="top"><a id="a1ce3fa58310d6acb433d74b51885cdc8" name="a1ce3fa58310d6acb433d74b51885cdc8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1ce3fa58310d6acb433d74b51885cdc8"><td class="memTemplItemLeft" align="right" valign="top">SharedQueue&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFromString&lt; SharedQueue&lt; std::string &gt; &gt;</b> (StringView str)</td></tr>
<tr class="separator:a1ce3fa58310d6acb433d74b51885cdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8bf6bcd4a2c94baf42a66f120bdf6d"><td class="memItemLeft" align="right" valign="top"><a id="a0f8bf6bcd4a2c94baf42a66f120bdf6d" name="a0f8bf6bcd4a2c94baf42a66f120bdf6d"></a>
Serialization::NodeType&#160;</td><td class="memItemRight" valign="bottom"><b>convertToFlatbuffers</b> (<a class="el" href="../../d2/d8d/namespace_b_t.html#a86a6454c13791311dface943d837363e">BT::NodeType</a> type)</td></tr>
<tr class="separator:a0f8bf6bcd4a2c94baf42a66f120bdf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44a2174009d509c8bab5a125671a2e7"><td class="memItemLeft" align="right" valign="top"><a id="ab44a2174009d509c8bab5a125671a2e7" name="ab44a2174009d509c8bab5a125671a2e7"></a>
Serialization::NodeStatus&#160;</td><td class="memItemRight" valign="bottom"><b>convertToFlatbuffers</b> (<a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">BT::NodeStatus</a> type)</td></tr>
<tr class="separator:ab44a2174009d509c8bab5a125671a2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56db878e523741adf0fdff57f66cb99"><td class="memItemLeft" align="right" valign="top"><a id="ac56db878e523741adf0fdff57f66cb99" name="ac56db878e523741adf0fdff57f66cb99"></a>
Serialization::PortDirection&#160;</td><td class="memItemRight" valign="bottom"><b>convertToFlatbuffers</b> (BT::PortDirection direction)</td></tr>
<tr class="separator:ac56db878e523741adf0fdff57f66cb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab34a90758e9b0e1fc5753530df7f61"><td class="memItemLeft" align="right" valign="top"><a id="a1ab34a90758e9b0e1fc5753530df7f61" name="a1ab34a90758e9b0e1fc5753530df7f61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFlatbuffersBehaviorTree</b> (flatbuffers::FlatBufferBuilder &amp;builder, const <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">BT::Tree</a> &amp;tree)</td></tr>
<tr class="separator:a1ab34a90758e9b0e1fc5753530df7f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5dd1ca538e17930637816c78ccba5a"><td class="memItemLeft" align="right" valign="top">SerializedTransition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a1e5dd1ca538e17930637816c78ccba5a">SerializeTransition</a> (uint16_t UID, Duration timestamp, <a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">NodeStatus</a> prev_status, <a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">NodeStatus</a> status)</td></tr>
<tr class="separator:a1e5dd1ca538e17930637816c78ccba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa246dac8b7086f1e0f27285c9fc3d126"><td class="memTemplParams" colspan="2"><a id="aa246dac8b7086f1e0f27285c9fc3d126" name="aa246dac8b7086f1e0f27285c9fc3d126"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa246dac8b7086f1e0f27285c9fc3d126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RegisterJsonDefinition</b> ()</td></tr>
<tr class="separator:aa246dac8b7086f1e0f27285c9fc3d126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28330518fc63ccc458b55303d05b18d1"><td class="memItemLeft" align="right" valign="top"><a id="a28330518fc63ccc458b55303d05b18d1" name="a28330518fc63ccc458b55303d05b18d1"></a>
<a class="el" href="../../d2/d8d/namespace_b_t.html#ad8e3c5c30d6bff91c95a9184fec5a2d5">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ValidateScript</b> (const std::string &amp;script)</td></tr>
<tr class="memdesc:a28330518fc63ccc458b55303d05b18d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ValidateScript will check if a certain string is valid. <br /></td></tr>
<tr class="separator:a28330518fc63ccc458b55303d05b18d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f36dbf3fafcf3e6a07191d128f6a72"><td class="memItemLeft" align="right" valign="top"><a id="ae4f36dbf3fafcf3e6a07191d128f6a72" name="ae4f36dbf3fafcf3e6a07191d128f6a72"></a>
<a class="el" href="../../d2/d8d/namespace_b_t.html#a7ed468293f4e7dc7ebbaca1a475526f3">Expected</a>&lt; ScriptFunction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ParseScript</b> (const std::string &amp;script)</td></tr>
<tr class="separator:ae4f36dbf3fafcf3e6a07191d128f6a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b07a8edfc95ffcc30d864cadeb4c43"><td class="memItemLeft" align="right" valign="top"><a id="ab2b07a8edfc95ffcc30d864cadeb4c43" name="ab2b07a8edfc95ffcc30d864cadeb4c43"></a>
<a class="el" href="../../d2/d8d/namespace_b_t.html#a7ed468293f4e7dc7ebbaca1a475526f3">Expected</a>&lt; <a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ParseScriptAndExecute</b> (<a class="el" href="../../d0/de8/struct_b_t_1_1_ast_1_1_environment.html">Ast::Environment</a> &amp;env, const std::string &amp;script)</td></tr>
<tr class="separator:ab2b07a8edfc95ffcc30d864cadeb4c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3b554eb6a64711b61a3dee286f16fe"><td class="memItemLeft" align="right" valign="top"><a id="afb3b554eb6a64711b61a3dee286f16fe" name="afb3b554eb6a64711b61a3dee286f16fe"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afb3b554eb6a64711b61a3dee286f16fe"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toStr&lt; BT::PostCond &gt;</b> (const BT::PostCond &amp;cond)</td></tr>
<tr class="separator:afb3b554eb6a64711b61a3dee286f16fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d827ddf8ef81a5f69c000553cae6975"><td class="memItemLeft" align="right" valign="top"><a id="a0d827ddf8ef81a5f69c000553cae6975" name="a0d827ddf8ef81a5f69c000553cae6975"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0d827ddf8ef81a5f69c000553cae6975"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toStr&lt; BT::PreCond &gt;</b> (const BT::PreCond &amp;cond)</td></tr>
<tr class="separator:a0d827ddf8ef81a5f69c000553cae6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847a4e84e268fdb6cee10726c54a148"><td class="memTemplParams" colspan="2"><a id="ac847a4e84e268fdb6cee10726c54a148" name="ac847a4e84e268fdb6cee10726c54a148"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac847a4e84e268fdb6cee10726c54a148"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hasNodeNameCtor</b> ()</td></tr>
<tr class="separator:ac847a4e84e268fdb6cee10726c54a148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a527afc9bbf1747dbe073d650e062c"><td class="memTemplParams" colspan="2"><a id="a91a527afc9bbf1747dbe073d650e062c" name="a91a527afc9bbf1747dbe073d650e062c"></a>
template&lt;typename T , typename... ExtraArgs&gt; </td></tr>
<tr class="memitem:a91a527afc9bbf1747dbe073d650e062c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hasNodeFullCtor</b> ()</td></tr>
<tr class="separator:a91a527afc9bbf1747dbe073d650e062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66927875be874fe0d023f2fd4d5e64c1"><td class="memTemplParams" colspan="2"><a id="a66927875be874fe0d023f2fd4d5e64c1" name="a66927875be874fe0d023f2fd4d5e64c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66927875be874fe0d023f2fd4d5e64c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignDefaultRemapping</b> (<a class="el" href="../../dc/d26/struct_b_t_1_1_node_config.html">NodeConfig</a> &amp;config)</td></tr>
<tr class="separator:a66927875be874fe0d023f2fd4d5e64c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268d8bfcb547fc723495ac8b1e877474"><td class="memItemLeft" align="right" valign="top"><a id="a268d8bfcb547fc723495ac8b1e877474" name="a268d8bfcb547fc723495ac8b1e877474"></a>
char const *&#160;</td><td class="memItemRight" valign="bottom"><b>demangle_alloc</b> (char const *name) noexcept</td></tr>
<tr class="separator:a268d8bfcb547fc723495ac8b1e877474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab580b641f0441efba3cedd7810a3266e"><td class="memItemLeft" align="right" valign="top"><a id="ab580b641f0441efba3cedd7810a3266e" name="ab580b641f0441efba3cedd7810a3266e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>demangle_free</b> (char const *name) noexcept</td></tr>
<tr class="separator:ab580b641f0441efba3cedd7810a3266e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052de3cbe0ceac2515691199582be4d8"><td class="memItemLeft" align="right" valign="top"><a id="a052de3cbe0ceac2515691199582be4d8" name="a052de3cbe0ceac2515691199582be4d8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>demangle</b> (char const *name)</td></tr>
<tr class="separator:a052de3cbe0ceac2515691199582be4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108fe00340bb807e1d8f6dbb621e9bab"><td class="memItemLeft" align="right" valign="top"><a id="a108fe00340bb807e1d8f6dbb621e9bab" name="a108fe00340bb807e1d8f6dbb621e9bab"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>demangle</b> (const std::type_index &amp;index)</td></tr>
<tr class="separator:a108fe00340bb807e1d8f6dbb621e9bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229446568b7aa2823b283d23e701602d"><td class="memItemLeft" align="right" valign="top"><a id="a229446568b7aa2823b283d23e701602d" name="a229446568b7aa2823b283d23e701602d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>demangle</b> (const std::type_info &amp;info)</td></tr>
<tr class="separator:a229446568b7aa2823b283d23e701602d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84f9b7c570b7cfa1e12fc7b8cd174b3"><td class="memTemplParams" colspan="2"><a id="af84f9b7c570b7cfa1e12fc7b8cd174b3" name="af84f9b7c570b7cfa1e12fc7b8cd174b3"></a>
template&lt;typename SRC , typename TO &gt; </td></tr>
<tr class="memitem:af84f9b7c570b7cfa1e12fc7b8cd174b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ValidCast</b> (const SRC &amp;val)</td></tr>
<tr class="separator:af84f9b7c570b7cfa1e12fc7b8cd174b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf94140920f33a6a27ff6f298caaccbb"><td class="memTemplParams" colspan="2"><a id="acf94140920f33a6a27ff6f298caaccbb" name="acf94140920f33a6a27ff6f298caaccbb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf94140920f33a6a27ff6f298caaccbb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isCastingSafe</b> (const std::type_index &amp;type, const T &amp;val)</td></tr>
<tr class="separator:acf94140920f33a6a27ff6f298caaccbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756e25757dafaa358a47e0d0fbb10174"><td class="memItemLeft" align="right" valign="top"><a id="a756e25757dafaa358a47e0d0fbb10174" name="a756e25757dafaa358a47e0d0fbb10174"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>StrCat</b> ()</td></tr>
<tr class="separator:a756e25757dafaa358a47e0d0fbb10174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c40df788c696a8050f64e4966e3722"><td class="memItemLeft" align="right" valign="top"><a id="a20c40df788c696a8050f64e4966e3722" name="a20c40df788c696a8050f64e4966e3722"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>StrCat</b> (const std::string_view &amp;a)</td></tr>
<tr class="separator:a20c40df788c696a8050f64e4966e3722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a896ee4bf620cb4b7b5c4e8efe6228"><td class="memItemLeft" align="right" valign="top"><a id="a37a896ee4bf620cb4b7b5c4e8efe6228" name="a37a896ee4bf620cb4b7b5c4e8efe6228"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>StrCat</b> (const std::string_view &amp;a, const std::string_view &amp;b)</td></tr>
<tr class="separator:a37a896ee4bf620cb4b7b5c4e8efe6228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9fe1e79728ecb14570792fcca4c4ae"><td class="memItemLeft" align="right" valign="top"><a id="a7a9fe1e79728ecb14570792fcca4c4ae" name="a7a9fe1e79728ecb14570792fcca4c4ae"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>StrCat</b> (const std::string_view &amp;a, const std::string_view &amp;b, const std::string_view &amp;c)</td></tr>
<tr class="separator:a7a9fe1e79728ecb14570792fcca4c4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2d09cbc17e288167ed427744e47112"><td class="memTemplParams" colspan="2"><a id="a0a2d09cbc17e288167ed427744e47112" name="a0a2d09cbc17e288167ed427744e47112"></a>
template&lt;typename... AV&gt; </td></tr>
<tr class="memitem:a0a2d09cbc17e288167ed427744e47112"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StrCat</b> (const std::string_view &amp;a, const std::string_view &amp;b, const std::string_view &amp;c, const std::string_view &amp;d, const AV &amp;... args)</td></tr>
<tr class="separator:a0a2d09cbc17e288167ed427744e47112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf879d71dd53e78362d396e41d42a501"><td class="memItemLeft" align="right" valign="top"><a id="abf879d71dd53e78362d396e41d42a501" name="abf879d71dd53e78362d396e41d42a501"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>StrAppend</b> (std::string *destination, const std::string_view &amp;a)</td></tr>
<tr class="separator:abf879d71dd53e78362d396e41d42a501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d445af5740aa2205a98969408ea6a9"><td class="memItemLeft" align="right" valign="top"><a id="af7d445af5740aa2205a98969408ea6a9" name="af7d445af5740aa2205a98969408ea6a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>StrAppend</b> (std::string *destination, const std::string_view &amp;a, const std::string_view &amp;b)</td></tr>
<tr class="separator:af7d445af5740aa2205a98969408ea6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a1ae4e29154fe59a7fc77db20aeb5"><td class="memItemLeft" align="right" valign="top"><a id="a3b7a1ae4e29154fe59a7fc77db20aeb5" name="a3b7a1ae4e29154fe59a7fc77db20aeb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>StrAppend</b> (std::string *destination, const std::string_view &amp;a, const std::string_view &amp;b, const std::string_view &amp;c)</td></tr>
<tr class="separator:a3b7a1ae4e29154fe59a7fc77db20aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f77f7abc461d57cb7d247678ce14a9"><td class="memTemplParams" colspan="2"><a id="a46f77f7abc461d57cb7d247678ce14a9" name="a46f77f7abc461d57cb7d247678ce14a9"></a>
template&lt;typename... AV&gt; </td></tr>
<tr class="memitem:a46f77f7abc461d57cb7d247678ce14a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StrAppend</b> (std::string *destination, const std::string_view &amp;a, const std::string_view &amp;b, const std::string_view &amp;c, const std::string_view &amp;d, const AV &amp;... args)</td></tr>
<tr class="separator:a46f77f7abc461d57cb7d247678ce14a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc3b13a1b83f8e5d21915eb9722a9a4"><td class="memItemLeft" align="right" valign="top"><a id="acfc3b13a1b83f8e5d21915eb9722a9a4" name="acfc3b13a1b83f8e5d21915eb9722a9a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VerifyXML</b> (const std::string &amp;xml_text, const std::unordered_map&lt; std::string, <a class="el" href="../../d2/d8d/namespace_b_t.html#a86a6454c13791311dface943d837363e">NodeType</a> &gt; &amp;registered_nodes)</td></tr>
<tr class="separator:acfc3b13a1b83f8e5d21915eb9722a9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f653b41d3df395036c6245ef3265424"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a7f653b41d3df395036c6245ef3265424">writeTreeNodesModelXML</a> (const <a class="el" href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html">BehaviorTreeFactory</a> &amp;factory, bool include_builtin=false)</td></tr>
<tr class="memdesc:a7f653b41d3df395036c6245ef3265424"><td class="mdescLeft">&#160;</td><td class="mdescRight">writeTreeNodesModelXML generates an XMl that contains the manifests in the &lt;TreeNodesModel&gt;  <br /></td></tr>
<tr class="separator:a7f653b41d3df395036c6245ef3265424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415454b3b6fe0ce36db71ef677c13a4e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a415454b3b6fe0ce36db71ef677c13a4e">writeTreeXSD</a> (const <a class="el" href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html">BehaviorTreeFactory</a> &amp;factory)</td></tr>
<tr class="memdesc:a415454b3b6fe0ce36db71ef677c13a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">writeTreeXSD generates an XSD for the nodes defined in the factory  <br /></td></tr>
<tr class="separator:a415454b3b6fe0ce36db71ef677c13a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a84d486b78c9a316e997bd3cc799f75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/namespace_b_t.html#a4a84d486b78c9a316e997bd3cc799f75">WriteTreeToXML</a> (const <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">Tree</a> &amp;tree, bool add_metadata, bool add_builtin_models)</td></tr>
<tr class="memdesc:a4a84d486b78c9a316e997bd3cc799f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteTreeToXML create a string that contains the XML that corresponds to a given tree. When using this function with a logger, you should probably set both add_metadata and add_builtin_models to true.  <br /></td></tr>
<tr class="separator:a4a84d486b78c9a316e997bd3cc799f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a530ee43efe3f486f5c1bba8e5a2370c5"><td class="memItemLeft" align="right" valign="top"><a id="a530ee43efe3f486f5c1bba8e5a2370c5" name="a530ee43efe3f486f5c1bba8e5a2370c5"></a>
constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>PLUGIN_SYMBOL</b> = &quot;BT_RegisterNodesFromPlugin&quot;</td></tr>
<tr class="separator:a530ee43efe3f486f5c1bba8e5a2370c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Template Action used in ex04_waypoints.cpp example.</p>
<p>Its purpose is to do make it easy to create while loops which consume the elements of a queue.</p>
<p>Note that modifying the queue is not thread safe, therefore the action that creates the queue or push elements into it, must be Synchronous.</p>
<p>When ticked, we pop_front from the "queue" and insert that value in "popped_item". Return FAILURE if the queue is empty, SUCCESS otherwise. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab3912e0e286d30ab35df23ed44632e4f" name="ab3912e0e286d30ab35df23ed44632e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3912e0e286d30ab35df23ed44632e4f">&#9670;&#160;</a></span>AnyPtrLocked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d8d/namespace_b_t.html#ab3912e0e286d30ab35df23ed44632e4f">BT::AnyPtrLocked</a> = typedef <a class="el" href="../../d4/d98/class_b_t_1_1_locked_ptr.html">LockedPtr</a>&lt;<a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type contains a pointer to <a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a>, protected with a locked mutex as long as the object is in scope </p>

</div>
</div>
<a id="aae2df96e431683d5655acbfe26026f59" name="aae2df96e431683d5655acbfe26026f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2df96e431683d5655acbfe26026f59">&#9670;&#160;</a></span>EnumsTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d8d/namespace_b_t.html#aae2df96e431683d5655acbfe26026f59">BT::EnumsTable</a> = typedef std::unordered_map&lt;std::string, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple map (string-&gt;nt), used to convert enums in the scripting language </p>

</div>
</div>
<a id="a7ed468293f4e7dc7ebbaca1a475526f3" name="a7ed468293f4e7dc7ebbaca1a475526f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed468293f4e7dc7ebbaca1a475526f3">&#9670;&#160;</a></span>Expected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d8d/namespace_b_t.html#a7ed468293f4e7dc7ebbaca1a475526f3">BT::Expected</a> = typedef nonstd::expected&lt;T, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usage: given a function/method like this:</p>
<p>Expected&lt;double&gt; getAnswer();</p>
<p>User code can check result and error message like this: </p><pre class="fragment">auto res = getAnswer();
if( res )
{
    std::cout &lt;&lt; "answer was: " &lt;&lt; res.value() &lt;&lt; std::endl;
}
else{
    std::cerr &lt;&lt; "failed to get the answer: " &lt;&lt; res.error() &lt;&lt; std::endl;
}
</pre> 
</div>
</div>
<a id="ad8e3c5c30d6bff91c95a9184fec5a2d5" name="ad8e3c5c30d6bff91c95a9184fec5a2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e3c5c30d6bff91c95a9184fec5a2d5">&#9670;&#160;</a></span>Result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d8d/namespace_b_t.html#ad8e3c5c30d6bff91c95a9184fec5a2d5">BT::Result</a> = typedef <a class="el" href="../../d2/d8d/namespace_b_t.html#a7ed468293f4e7dc7ebbaca1a475526f3">Expected</a>&lt;std::monostate&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usage: given a function/method like:</p>
<p>Result DoSomething();</p>
<p>User code can check result and error message like this: </p><pre class="fragment">auto res = DoSomething();
if( res )
{
    std::cout &lt;&lt; "DoSomething() done " &lt;&lt; std::endl;
}
else{
    std::cerr &lt;&lt; "DoSomething() failed with message: " &lt;&lt; res.error() &lt;&lt; std::endl;
}
</pre> 
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1414a8362678cd4081eeb30b72845b4e" name="a1414a8362678cd4081eeb30b72845b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1414a8362678cd4081eeb30b72845b4e">&#9670;&#160;</a></span>NodeStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">BT::NodeStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerates the states every node can be in after execution during a particular time step. IMPORTANT: Your custom nodes should NEVER return IDLE. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa5246156c75012e4106eb05bc9c3cf47" name="aa5246156c75012e4106eb05bc9c3cf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5246156c75012e4106eb05bc9c3cf47">&#9670;&#160;</a></span>BidirectionalPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = AnyTypeAllowed, typename DefaultT  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt; BT::BidirectionalPort </td>
          <td>(</td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DefaultT &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Syntactic sugar to invoke CreatePort&lt;T&gt;(PortDirection::INOUT,...) It also sets the PortInfo::defaultValue()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the port </td></tr>
    <tr><td class="paramname">default_value</td><td>default value of the port, either type T of BlackboardKey </td></tr>
    <tr><td class="paramname">description</td><td>optional human-readable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13321f9dceb6909198966973042a13a1" name="a13321f9dceb6909198966973042a13a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13321f9dceb6909198966973042a13a1">&#9670;&#160;</a></span>BidirectionalPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = AnyTypeAllowed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt; BT::BidirectionalPort </td>
          <td>(</td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>description</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Syntactic sugar to invoke CreatePort&lt;T&gt;(PortDirection::INOUT,...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the port </td></tr>
    <tr><td class="paramname">description</td><td>optional human-readable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39d3de37134ad6c26809809a99c85cd1" name="a39d3de37134ad6c26809809a99c85cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d3de37134ad6c26809809a99c85cd1">&#9670;&#160;</a></span>BlackboardBackup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Blackboard::Ptr &gt; BT::BlackboardBackup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">BT::Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BlackboardBackup uses <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html#afd93b989bbb7add02e649a039c0c0b5e" title="cloneInto copies the values of the entries into another blackboard. Known limitations:">Blackboard::cloneInto</a> to backup all the blackboards of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>destination (the backup) </dd></dl>

</div>
</div>
<a id="ae1c2a1676d84ad1a9b3a809c7c8e8fdb" name="ae1c2a1676d84ad1a9b3a809c7c8e8fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c2a1676d84ad1a9b3a809c7c8e8fdb">&#9670;&#160;</a></span>BlackboardClone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BT::BlackboardClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html">Blackboard</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html">Blackboard</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BlackboardClone make a copy of the content of the blackboard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source </td></tr>
    <tr><td class="paramname">dst</td><td>destination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fd0bac756271d4c997ed0a3d67067c1" name="a9fd0bac756271d4c997ed0a3d67067c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd0bac756271d4c997ed0a3d67067c1">&#9670;&#160;</a></span>BlackboardRestore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BT::BlackboardRestore </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Blackboard::Ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>backup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">BT::Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BlackboardRestore uses <a class="el" href="../../d0/d51/class_b_t_1_1_blackboard.html#afd93b989bbb7add02e649a039c0c0b5e" title="cloneInto copies the values of the entries into another blackboard. Known limitations:">Blackboard::cloneInto</a> to restore all the blackboards of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backup</td><td>a vector of blackboards </td></tr>
    <tr><td class="paramname">tree</td><td>the destination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa260ec6d0ad8a20a2beff083a470d6ce" name="aa260ec6d0ad8a20a2beff083a470d6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa260ec6d0ad8a20a2beff083a470d6ce">&#9670;&#160;</a></span>buildSerializedStatusSnapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BT::buildSerializedStatusSnapshot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerializedTreeStatus &amp;&#160;</td>
          <td class="paramname"><em>serialized_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buildSerializedStatusSnapshot can be used to create a buffer that can be stored (or sent to a client application) to know the status of all the nodes of a tree. It is not "human readable". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_node</td><td></td></tr>
    <tr><td class="paramname">serialized_buffer</td><td>is the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a183200576f5fa139ae3359abbe8ef1c4" name="a183200576f5fa139ae3359abbe8ef1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183200576f5fa139ae3359abbe8ef1c4">&#9670;&#160;</a></span>convertFromJSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a> BT::convertFromJSON </td>
          <td>(</td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>json_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convertFromJSON will parse a json string and use <a class="el" href="../../d0/d64/class_b_t_1_1_json_exporter.html">JsonExporter</a> to convert its content to a given type. It will work only if the type was previously registered. May throw if it fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json_text</td><td>a valid JSON string </td></tr>
    <tr><td class="paramname">type</td><td>you must specify the typeid() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object, wrapped in <a class="el" href="../../d7/df4/class_b_t_1_1_any.html">Any</a>. </dd></dl>

</div>
</div>
<a id="afaf200f50db2b15eea2e20e6a068a0d2" name="afaf200f50db2b15eea2e20e6a068a0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf200f50db2b15eea2e20e6a068a0d2">&#9670;&#160;</a></span>convertFromString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T BT::convertFromString </td>
          <td>(</td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>convertFromString is used to convert a string into a custom type.</p>
<p>This function is invoked under the hood by <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html#ae921e5800a82b7591cb711c710d49725">TreeNode::getInput()</a>, but only when the input port contains a string.</p>
<p>If you have a custom type, you need to implement the corresponding template specialization.</p>
<p>If the string starts with the prefix "json:", it will fall back to <a class="el" href="../../d2/d8d/namespace_b_t.html#a183200576f5fa139ae3359abbe8ef1c4" title="convertFromJSON will parse a json string and use JsonExporter to convert its content to a given type....">convertFromJSON()</a> </p>

</div>
</div>
<a id="aa8bda3dd22bdb1c2aaa354a610e25ac9" name="aa8bda3dd22bdb1c2aaa354a610e25ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bda3dd22bdb1c2aaa354a610e25ac9">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d8d/namespace_b_t.html#a86a6454c13791311dface943d837363e">NodeType</a> BT::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple way to extract the type of a <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html" title="Abstract base class for Behavior Tree Nodes.">TreeNode</a> at COMPILE TIME. Useful to avoid the cost of dynamic_cast or the virtual method TreeNode::type(). </p>

</div>
</div>
<a id="a8794519d3bc2203f70a65b38f9e37a3c" name="a8794519d3bc2203f70a65b38f9e37a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8794519d3bc2203f70a65b38f9e37a3c">&#9670;&#160;</a></span>InputPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = AnyTypeAllowed, typename DefaultT  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt; BT::InputPort </td>
          <td>(</td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DefaultT &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Syntactic sugar to invoke CreatePort&lt;T&gt;(PortDirection::INPUT,...) It also sets the PortInfo::defaultValue()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the port </td></tr>
    <tr><td class="paramname">default_value</td><td>default value of the port, either type T of BlackboardKey </td></tr>
    <tr><td class="paramname">description</td><td>optional human-readable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d63b9f7eba8a9a98322107ef8e0ae3d" name="a9d63b9f7eba8a9a98322107ef8e0ae3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d63b9f7eba8a9a98322107ef8e0ae3d">&#9670;&#160;</a></span>InputPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = AnyTypeAllowed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt; BT::InputPort </td>
          <td>(</td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>description</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Syntactic sugar to invoke CreatePort&lt;T&gt;(PortDirection::INPUT, ...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the port </td></tr>
    <tr><td class="paramname">description</td><td>optional human-readable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a533a06e2f82bd5d915194dcb696f444c" name="a533a06e2f82bd5d915194dcb696f444c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533a06e2f82bd5d915194dcb696f444c">&#9670;&#160;</a></span>OutputPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = AnyTypeAllowed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt; BT::OutputPort </td>
          <td>(</td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Syntactic sugar to invoke CreatePort&lt;T&gt;(PortDirection::OUTPUT,...) It also sets the PortInfo::defaultValue()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the port </td></tr>
    <tr><td class="paramname">default_value</td><td>default blackboard entry where the output is written </td></tr>
    <tr><td class="paramname">description</td><td>optional human-readable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ac171179c71fc0def23cf28e36b8ee2" name="a8ac171179c71fc0def23cf28e36b8ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac171179c71fc0def23cf28e36b8ee2">&#9670;&#160;</a></span>OutputPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = AnyTypeAllowed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="../../d8/d5e/class_b_t_1_1_port_info.html">PortInfo</a> &gt; BT::OutputPort </td>
          <td>(</td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringView&#160;</td>
          <td class="paramname"><em>description</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Syntactic sugar to invoke CreatePort&lt;T&gt;(PortDirection::OUTPUT,...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the port </td></tr>
    <tr><td class="paramname">description</td><td>optional human-readable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81fc68e6864ea125011a4ab64e9d6dc3" name="a81fc68e6864ea125011a4ab64e9d6dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fc68e6864ea125011a4ab64e9d6dc3">&#9670;&#160;</a></span>printTreeRecursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BT::printTreeRecursively </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d61/class_b_t_1_1_tree_node.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debug function to print the hierarchy of the tree. Prints to std::cout by default. </p>

</div>
</div>
<a id="a1e5dd1ca538e17930637816c78ccba5a" name="a1e5dd1ca538e17930637816c78ccba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5dd1ca538e17930637816c78ccba5a">&#9670;&#160;</a></span>SerializeTransition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SerializedTransition BT::SerializeTransition </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>UID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Duration&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">NodeStatus</a>&#160;</td>
          <td class="paramname"><em>prev_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d8d/namespace_b_t.html#a1414a8362678cd4081eeb30b72845b4e">NodeStatus</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serialize manually the information about state transition No flatbuffer serialization here </p>

</div>
</div>
<a id="acdc7285d759ccee669271f9884941cf9" name="acdc7285d759ccee669271f9884941cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc7285d759ccee669271f9884941cf9">&#9670;&#160;</a></span>toStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string BT::toStr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>toStr is the reverse operation of convertFromString. </p>
<p>If T is a custom type and there is no template specialization, it will try to fall back to toJsonString() </p>

</div>
</div>
<a id="a7f653b41d3df395036c6245ef3265424" name="a7f653b41d3df395036c6245ef3265424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f653b41d3df395036c6245ef3265424">&#9670;&#160;</a></span>writeTreeNodesModelXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string BT::writeTreeNodesModelXML </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html">BehaviorTreeFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_builtin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writeTreeNodesModelXML generates an XMl that contains the manifests in the &lt;TreeNodesModel&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>the factory with the registered types </td></tr>
    <tr><td class="paramname">include_builtin</td><td>if true, include the builtin Nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing the XML. </dd></dl>

</div>
</div>
<a id="a4a84d486b78c9a316e997bd3cc799f75" name="a4a84d486b78c9a316e997bd3cc799f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a84d486b78c9a316e997bd3cc799f75">&#9670;&#160;</a></span>WriteTreeToXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string BT::WriteTreeToXML </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d79/class_b_t_1_1_tree.html">Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_builtin_models</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WriteTreeToXML create a string that contains the XML that corresponds to a given tree. When using this function with a logger, you should probably set both add_metadata and add_builtin_models to true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the input tree </td></tr>
    <tr><td class="paramname">add_metadata</td><td>if true, the attributes "_uid" and "_fullPath" will be added to the nodes </td></tr>
    <tr><td class="paramname">add_builtin_models</td><td>if true, include the builtin Nodes into the &lt;TreeNodesModel&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing the XML. </dd></dl>

</div>
</div>
<a id="a415454b3b6fe0ce36db71ef677c13a4e" name="a415454b3b6fe0ce36db71ef677c13a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415454b3b6fe0ce36db71ef677c13a4e">&#9670;&#160;</a></span>writeTreeXSD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string BT::writeTreeXSD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dcd/class_b_t_1_1_behavior_tree_factory.html">BehaviorTreeFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writeTreeXSD generates an XSD for the nodes defined in the factory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>the factory with the registered types</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing the XML. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d2/d8d/namespace_b_t.html">BT</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
