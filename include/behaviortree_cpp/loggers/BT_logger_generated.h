// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

namespace BT_Serialization
{
struct Timestamp;

struct KeyValue;

struct TreeNode;

struct BehaviorTree;

struct StatusChange;

struct StatusChangeLog;

enum class Status : int8_t
{
    IDLE = 0,
    RUNNING = 1,
    SUCCESS = 2,
    FAILURE = 3,
    MIN = IDLE,
    MAX = FAILURE
};

inline const Status (&EnumValuesStatus())[4]
{
    static const Status values[] = {Status::IDLE, Status::RUNNING, Status::SUCCESS,
                                    Status::FAILURE};
    return values;
}

inline const char* const* EnumNamesStatus()
{
    static const char* const names[] = {"IDLE", "RUNNING", "SUCCESS", "FAILURE", nullptr};
    return names;
}

inline const char* EnumNameStatus(Status e)
{
    const size_t index = static_cast<int>(e);
    return EnumNamesStatus()[index];
}

enum class Type : int8_t
{
    UNDEFINED = 0,
    ACTION = 1,
    CONDITION = 2,
    CONTROL = 3,
    DECORATOR = 4,
    SUBTREE = 5,
    MIN = UNDEFINED,
    MAX = SUBTREE
};

inline const Type (&EnumValuesType())[6]
{
    static const Type values[] = {Type::UNDEFINED, Type::ACTION,    Type::CONDITION,
                                  Type::CONTROL,   Type::DECORATOR, Type::SUBTREE};
    return values;
}

inline const char* const* EnumNamesType()
{
    static const char* const names[] = {"UNDEFINED", "ACTION",  "CONDITION", "CONTROL",
                                        "DECORATOR", "SUBTREE", nullptr};
    return names;
}

inline const char* EnumNameType(Type e)
{
    const size_t index = static_cast<int>(e);
    return EnumNamesType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Timestamp FLATBUFFERS_FINAL_CLASS
{
  private:
    uint64_t usec_since_epoch_;

  public:
    Timestamp()
    {
        memset(this, 0, sizeof(Timestamp));
    }
    Timestamp(uint64_t _usec_since_epoch)
      : usec_since_epoch_(flatbuffers::EndianScalar(_usec_since_epoch))
    {
    }
    uint64_t usec_since_epoch() const
    {
        return flatbuffers::EndianScalar(usec_since_epoch_);
    }
};
FLATBUFFERS_STRUCT_END(Timestamp, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) StatusChange FLATBUFFERS_FINAL_CLASS
{
  private:
    uint16_t uid_;
    int8_t prev_status_;
    int8_t status_;
    int32_t padding0__;
    Timestamp timestamp_;

  public:
    StatusChange()
    {
        memset(this, 0, sizeof(StatusChange));
    }
    StatusChange(uint16_t _uid, Status _prev_status, Status _status, const Timestamp& _timestamp)
      : uid_(flatbuffers::EndianScalar(_uid))
      , prev_status_(flatbuffers::EndianScalar(static_cast<int8_t>(_prev_status)))
      , status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status)))
      , padding0__(0)
      , timestamp_(_timestamp)
    {
        (void)padding0__;
    }
    uint16_t uid() const
    {
        return flatbuffers::EndianScalar(uid_);
    }
    Status prev_status() const
    {
        return static_cast<Status>(flatbuffers::EndianScalar(prev_status_));
    }
    Status status() const
    {
        return static_cast<Status>(flatbuffers::EndianScalar(status_));
    }
    const Timestamp& timestamp() const
    {
        return timestamp_;
    }
};
FLATBUFFERS_STRUCT_END(StatusChange, 16);

struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
    enum
    {
        VT_KEY = 4,
        VT_VALUE = 6
    };
    const flatbuffers::String* key() const
    {
        return GetPointer<const flatbuffers::String*>(VT_KEY);
    }
    const flatbuffers::String* value() const
    {
        return GetPointer<const flatbuffers::String*>(VT_VALUE);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_KEY) &&
               verifier.Verify(key()) && VerifyOffset(verifier, VT_VALUE) &&
               verifier.Verify(value()) && verifier.EndTable();
    }
};

struct KeyValueBuilder
{
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_key(flatbuffers::Offset<flatbuffers::String> key)
    {
        fbb_.AddOffset(KeyValue::VT_KEY, key);
    }
    void add_value(flatbuffers::Offset<flatbuffers::String> value)
    {
        fbb_.AddOffset(KeyValue::VT_VALUE, value);
    }
    explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    KeyValueBuilder& operator=(const KeyValueBuilder&);
    flatbuffers::Offset<KeyValue> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<KeyValue>(end);
        return o;
    }
};

inline flatbuffers::Offset<KeyValue> CreateKeyValue(
    flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0)
{
    KeyValueBuilder builder_(_fbb);
    builder_.add_value(value);
    builder_.add_key(key);
    return builder_.Finish();
}

inline flatbuffers::Offset<KeyValue> CreateKeyValueDirect(flatbuffers::FlatBufferBuilder& _fbb,
                                                          const char* key = nullptr,
                                                          const char* value = nullptr)
{
    return BT_Serialization::CreateKeyValue(_fbb, key ? _fbb.CreateString(key) : 0,
                                            value ? _fbb.CreateString(value) : 0);
}

struct TreeNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
    enum
    {
        VT_UID = 4,
        VT_CHILDREN_UID = 6,
        VT_TYPE = 8,
        VT_STATUS = 10,
        VT_INSTANCE_NAME = 12,
        VT_REGISTRATION_NAME = 14,
        VT_PARAMS = 16
    };
    uint16_t uid() const
    {
        return GetField<uint16_t>(VT_UID, 0);
    }
    const flatbuffers::Vector<uint16_t>* children_uid() const
    {
        return GetPointer<const flatbuffers::Vector<uint16_t>*>(VT_CHILDREN_UID);
    }
    Type type() const
    {
        return static_cast<Type>(GetField<int8_t>(VT_TYPE, 0));
    }
    Status status() const
    {
        return static_cast<Status>(GetField<int8_t>(VT_STATUS, 0));
    }
    const flatbuffers::String* instance_name() const
    {
        return GetPointer<const flatbuffers::String*>(VT_INSTANCE_NAME);
    }
    const flatbuffers::String* registration_name() const
    {
        return GetPointer<const flatbuffers::String*>(VT_REGISTRATION_NAME);
    }
    const flatbuffers::Vector<flatbuffers::Offset<KeyValue>>* params() const
    {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValue>>*>(VT_PARAMS);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_UID) &&
               VerifyOffset(verifier, VT_CHILDREN_UID) && verifier.Verify(children_uid()) &&
               VerifyField<int8_t>(verifier, VT_TYPE) && VerifyField<int8_t>(verifier, VT_STATUS) &&
               VerifyOffsetRequired(verifier, VT_INSTANCE_NAME) &&
               verifier.Verify(instance_name()) &&
               VerifyOffsetRequired(verifier, VT_REGISTRATION_NAME) &&
               verifier.Verify(registration_name()) && VerifyOffset(verifier, VT_PARAMS) &&
               verifier.Verify(params()) && verifier.VerifyVectorOfTables(params()) &&
               verifier.EndTable();
    }
};

struct TreeNodeBuilder
{
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_uid(uint16_t uid)
    {
        fbb_.AddElement<uint16_t>(TreeNode::VT_UID, uid, 0);
    }
    void add_children_uid(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> children_uid)
    {
        fbb_.AddOffset(TreeNode::VT_CHILDREN_UID, children_uid);
    }
    void add_type(Type type)
    {
        fbb_.AddElement<int8_t>(TreeNode::VT_TYPE, static_cast<int8_t>(type), 0);
    }
    void add_status(Status status)
    {
        fbb_.AddElement<int8_t>(TreeNode::VT_STATUS, static_cast<int8_t>(status), 0);
    }
    void add_instance_name(flatbuffers::Offset<flatbuffers::String> instance_name)
    {
        fbb_.AddOffset(TreeNode::VT_INSTANCE_NAME, instance_name);
    }
    void add_registration_name(flatbuffers::Offset<flatbuffers::String> registration_name)
    {
        fbb_.AddOffset(TreeNode::VT_REGISTRATION_NAME, registration_name);
    }
    void add_params(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> params)
    {
        fbb_.AddOffset(TreeNode::VT_PARAMS, params);
    }
    explicit TreeNodeBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    TreeNodeBuilder& operator=(const TreeNodeBuilder&);
    flatbuffers::Offset<TreeNode> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<TreeNode>(end);
        fbb_.Required(o, TreeNode::VT_INSTANCE_NAME);
        fbb_.Required(o, TreeNode::VT_REGISTRATION_NAME);
        return o;
    }
};

inline flatbuffers::Offset<TreeNode>
CreateTreeNode(flatbuffers::FlatBufferBuilder& _fbb, uint16_t uid = 0,
               flatbuffers::Offset<flatbuffers::Vector<uint16_t>> children_uid = 0,
               Type type = Type::UNDEFINED, Status status = Status::IDLE,
               flatbuffers::Offset<flatbuffers::String> instance_name = 0,
               flatbuffers::Offset<flatbuffers::String> registration_name = 0,
               flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> params = 0)
{
    TreeNodeBuilder builder_(_fbb);
    builder_.add_params(params);
    builder_.add_registration_name(registration_name);
    builder_.add_instance_name(instance_name);
    builder_.add_children_uid(children_uid);
    builder_.add_uid(uid);
    builder_.add_status(status);
    builder_.add_type(type);
    return builder_.Finish();
}

inline flatbuffers::Offset<TreeNode>
CreateTreeNodeDirect(flatbuffers::FlatBufferBuilder& _fbb, uint16_t uid = 0,
                     const std::vector<uint16_t>* children_uid = nullptr,
                     Type type = Type::UNDEFINED, Status status = Status::IDLE,
                     const char* instance_name = nullptr, const char* registration_name = nullptr,
                     const std::vector<flatbuffers::Offset<KeyValue>>* params = nullptr)
{
    return BT_Serialization::CreateTreeNode(
        _fbb, uid, children_uid ? _fbb.CreateVector<uint16_t>(*children_uid) : 0, type, status,
        instance_name ? _fbb.CreateString(instance_name) : 0,
        registration_name ? _fbb.CreateString(registration_name) : 0,
        params ? _fbb.CreateVector<flatbuffers::Offset<KeyValue>>(*params) : 0);
}

struct BehaviorTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
    enum
    {
        VT_ROOT_UID = 4,
        VT_NODES = 6
    };
    uint16_t root_uid() const
    {
        return GetField<uint16_t>(VT_ROOT_UID, 0);
    }
    const flatbuffers::Vector<flatbuffers::Offset<TreeNode>>* nodes() const
    {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TreeNode>>*>(VT_NODES);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_ROOT_UID) &&
               VerifyOffset(verifier, VT_NODES) && verifier.Verify(nodes()) &&
               verifier.VerifyVectorOfTables(nodes()) && verifier.EndTable();
    }
};

struct BehaviorTreeBuilder
{
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_root_uid(uint16_t root_uid)
    {
        fbb_.AddElement<uint16_t>(BehaviorTree::VT_ROOT_UID, root_uid, 0);
    }
    void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> nodes)
    {
        fbb_.AddOffset(BehaviorTree::VT_NODES, nodes);
    }
    explicit BehaviorTreeBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    BehaviorTreeBuilder& operator=(const BehaviorTreeBuilder&);
    flatbuffers::Offset<BehaviorTree> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<BehaviorTree>(end);
        return o;
    }
};

inline flatbuffers::Offset<BehaviorTree> CreateBehaviorTree(
    flatbuffers::FlatBufferBuilder& _fbb, uint16_t root_uid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> nodes = 0)
{
    BehaviorTreeBuilder builder_(_fbb);
    builder_.add_nodes(nodes);
    builder_.add_root_uid(root_uid);
    return builder_.Finish();
}

inline flatbuffers::Offset<BehaviorTree>
CreateBehaviorTreeDirect(flatbuffers::FlatBufferBuilder& _fbb, uint16_t root_uid = 0,
                         const std::vector<flatbuffers::Offset<TreeNode>>* nodes = nullptr)
{
    return BT_Serialization::CreateBehaviorTree(
        _fbb, root_uid, nodes ? _fbb.CreateVector<flatbuffers::Offset<TreeNode>>(*nodes) : 0);
}

struct StatusChangeLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
    enum
    {
        VT_BEHAVIOR_TREE = 4,
        VT_STATE_CHANGES = 6
    };
    const BehaviorTree* behavior_tree() const
    {
        return GetPointer<const BehaviorTree*>(VT_BEHAVIOR_TREE);
    }
    const flatbuffers::Vector<const StatusChange*>* state_changes() const
    {
        return GetPointer<const flatbuffers::Vector<const StatusChange*>*>(VT_STATE_CHANGES);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BEHAVIOR_TREE) &&
               verifier.VerifyTable(behavior_tree()) && VerifyOffset(verifier, VT_STATE_CHANGES) &&
               verifier.Verify(state_changes()) && verifier.EndTable();
    }
};

struct StatusChangeLogBuilder
{
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_behavior_tree(flatbuffers::Offset<BehaviorTree> behavior_tree)
    {
        fbb_.AddOffset(StatusChangeLog::VT_BEHAVIOR_TREE, behavior_tree);
    }
    void
    add_state_changes(flatbuffers::Offset<flatbuffers::Vector<const StatusChange*>> state_changes)
    {
        fbb_.AddOffset(StatusChangeLog::VT_STATE_CHANGES, state_changes);
    }
    explicit StatusChangeLogBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    StatusChangeLogBuilder& operator=(const StatusChangeLogBuilder&);
    flatbuffers::Offset<StatusChangeLog> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<StatusChangeLog>(end);
        return o;
    }
};

inline flatbuffers::Offset<StatusChangeLog> CreateStatusChangeLog(
    flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<BehaviorTree> behavior_tree = 0,
    flatbuffers::Offset<flatbuffers::Vector<const StatusChange*>> state_changes = 0)
{
    StatusChangeLogBuilder builder_(_fbb);
    builder_.add_state_changes(state_changes);
    builder_.add_behavior_tree(behavior_tree);
    return builder_.Finish();
}

inline flatbuffers::Offset<StatusChangeLog> CreateStatusChangeLogDirect(
    flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<BehaviorTree> behavior_tree = 0,
    const std::vector<StatusChange>* state_changes = nullptr)
{
    return BT_Serialization::CreateStatusChangeLog(
        _fbb, behavior_tree,
        state_changes ? _fbb.CreateVectorOfStructs<StatusChange>(*state_changes) : 0);
}

inline const BT_Serialization::BehaviorTree* GetBehaviorTree(const void* buf)
{
    return flatbuffers::GetRoot<BT_Serialization::BehaviorTree>(buf);
}

inline const BT_Serialization::BehaviorTree* GetSizePrefixedBehaviorTree(const void* buf)
{
    return flatbuffers::GetSizePrefixedRoot<BT_Serialization::BehaviorTree>(buf);
}

inline bool VerifyBehaviorTreeBuffer(flatbuffers::Verifier& verifier)
{
    return verifier.VerifyBuffer<BT_Serialization::BehaviorTree>(nullptr);
}

inline bool VerifySizePrefixedBehaviorTreeBuffer(flatbuffers::Verifier& verifier)
{
    return verifier.VerifySizePrefixedBuffer<BT_Serialization::BehaviorTree>(nullptr);
}

inline void FinishBehaviorTreeBuffer(flatbuffers::FlatBufferBuilder& fbb,
                                     flatbuffers::Offset<BT_Serialization::BehaviorTree> root)
{
    fbb.Finish(root);
}

inline void FinishSizePrefixedBehaviorTreeBuffer(
    flatbuffers::FlatBufferBuilder& fbb, flatbuffers::Offset<BT_Serialization::BehaviorTree> root)
{
    fbb.FinishSizePrefixed(root);
}

}   // namespace BT_Serialization

#endif   // FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_
