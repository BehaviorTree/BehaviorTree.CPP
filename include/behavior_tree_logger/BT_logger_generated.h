// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

namespace BT_Serialization
{
struct Timestamp;

struct TreeNode;

struct BehaviorTree;

struct StatusChange;

struct StatusChangeLog;

enum class Status : int8_t
{
    IDLE = 0,
    RUNNING = 1,
    SUCCESS = 2,
    FAILURE = 3,
    MIN = IDLE,
    MAX = FAILURE
};

inline const Status (&EnumValuesStatus())[4]
{
    static const Status values[] = {Status::IDLE, Status::RUNNING, Status::SUCCESS, Status::FAILURE};
    return values;
}

inline const char* const* EnumNamesStatus()
{
    static const char* const names[] = {"IDLE", "RUNNING", "SUCCESS", "FAILURE", nullptr};
    return names;
}

inline const char* EnumNameStatus(Status e)
{
    const size_t index = static_cast<int>(e);
    return EnumNamesStatus()[index];
}

enum class Type : int8_t
{
    UNDEFINED = 0,
    ACTION = 1,
    CONDITION = 2,
    CONTROL = 3,
    DECORATOR = 4,
    SUBTREE = 5,
    MIN = UNDEFINED,
    MAX = SUBTREE
};

inline const Type (&EnumValuesType())[6]
{
    static const Type values[] = {Type::UNDEFINED, Type::ACTION,    Type::CONDITION,
                                  Type::CONTROL,   Type::DECORATOR, Type::SUBTREE};
    return values;
}

inline const char* const* EnumNamesType()
{
    static const char* const names[] = {"UNDEFINED", "ACTION", "CONDITION", "CONTROL", "DECORATOR", "SUBTREE", nullptr};
    return names;
}

inline const char* EnumNameType(Type e)
{
    const size_t index = static_cast<int>(e);
    return EnumNamesType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Timestamp FLATBUFFERS_FINAL_CLASS
{
  private:
    uint64_t usec_since_epoch_;

  public:
    Timestamp()
    {
        memset(this, 0, sizeof(Timestamp));
    }
    Timestamp(uint64_t _usec_since_epoch) : usec_since_epoch_(flatbuffers::EndianScalar(_usec_since_epoch))
    {
    }
    uint64_t usec_since_epoch() const
    {
        return flatbuffers::EndianScalar(usec_since_epoch_);
    }
};
FLATBUFFERS_STRUCT_END(Timestamp, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) StatusChange FLATBUFFERS_FINAL_CLASS
{
  private:
    uint16_t uid_;
    int8_t prev_status_;
    int8_t status_;
    int32_t padding0__;
    Timestamp timestamp_;

  public:
    StatusChange()
    {
        memset(this, 0, sizeof(StatusChange));
    }
    StatusChange(uint16_t _uid, Status _prev_status, Status _status, const Timestamp& _timestamp)
      : uid_(flatbuffers::EndianScalar(_uid))
      , prev_status_(flatbuffers::EndianScalar(static_cast<int8_t>(_prev_status)))
      , status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status)))
      , padding0__(0)
      , timestamp_(_timestamp)
    {
        (void)padding0__;
    }
    uint16_t uid() const
    {
        return flatbuffers::EndianScalar(uid_);
    }
    Status prev_status() const
    {
        return static_cast<Status>(flatbuffers::EndianScalar(prev_status_));
    }
    Status status() const
    {
        return static_cast<Status>(flatbuffers::EndianScalar(status_));
    }
    const Timestamp& timestamp() const
    {
        return timestamp_;
    }
};
FLATBUFFERS_STRUCT_END(StatusChange, 16);

struct TreeNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
    enum
    {
        VT_UID = 4,
        VT_CHILDREN_UID = 6,
        VT_TYPE = 8,
        VT_STATUS = 10,
        VT_INSTANCE_NAME = 12,
        VT_REGISTRATION_NAME = 14
    };
    uint16_t uid() const
    {
        return GetField<uint16_t>(VT_UID, 0);
    }
    const flatbuffers::Vector<uint16_t>* children_uid() const
    {
        return GetPointer<const flatbuffers::Vector<uint16_t>*>(VT_CHILDREN_UID);
    }
    Type type() const
    {
        return static_cast<Type>(GetField<int8_t>(VT_TYPE, 0));
    }
    Status status() const
    {
        return static_cast<Status>(GetField<int8_t>(VT_STATUS, 0));
    }
    const flatbuffers::String* instance_name() const
    {
        return GetPointer<const flatbuffers::String*>(VT_INSTANCE_NAME);
    }
    const flatbuffers::String* registration_name() const
    {
        return GetPointer<const flatbuffers::String*>(VT_REGISTRATION_NAME);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_UID) &&
               VerifyOffset(verifier, VT_CHILDREN_UID) && verifier.Verify(children_uid()) &&
               VerifyField<int8_t>(verifier, VT_TYPE) && VerifyField<int8_t>(verifier, VT_STATUS) &&
               VerifyOffsetRequired(verifier, VT_INSTANCE_NAME) && verifier.Verify(instance_name()) &&
               VerifyOffsetRequired(verifier, VT_REGISTRATION_NAME) && verifier.Verify(registration_name()) &&
               verifier.EndTable();
    }
};

struct TreeNodeBuilder
{
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_uid(uint16_t uid)
    {
        fbb_.AddElement<uint16_t>(TreeNode::VT_UID, uid, 0);
    }
    void add_children_uid(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> children_uid)
    {
        fbb_.AddOffset(TreeNode::VT_CHILDREN_UID, children_uid);
    }
    void add_type(Type type)
    {
        fbb_.AddElement<int8_t>(TreeNode::VT_TYPE, static_cast<int8_t>(type), 0);
    }
    void add_status(Status status)
    {
        fbb_.AddElement<int8_t>(TreeNode::VT_STATUS, static_cast<int8_t>(status), 0);
    }
    void add_instance_name(flatbuffers::Offset<flatbuffers::String> instance_name)
    {
        fbb_.AddOffset(TreeNode::VT_INSTANCE_NAME, instance_name);
    }
    void add_registration_name(flatbuffers::Offset<flatbuffers::String> registration_name)
    {
        fbb_.AddOffset(TreeNode::VT_REGISTRATION_NAME, registration_name);
    }
    explicit TreeNodeBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    TreeNodeBuilder& operator=(const TreeNodeBuilder&);
    flatbuffers::Offset<TreeNode> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<TreeNode>(end);
        fbb_.Required(o, TreeNode::VT_INSTANCE_NAME);
        fbb_.Required(o, TreeNode::VT_REGISTRATION_NAME);
        return o;
    }
};

inline flatbuffers::Offset<TreeNode> CreateTreeNode(flatbuffers::FlatBufferBuilder& _fbb, uint16_t uid = 0,
                                                    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> children_uid = 0,
                                                    Type type = Type::UNDEFINED, Status status = Status::IDLE,
                                                    flatbuffers::Offset<flatbuffers::String> instance_name = 0,
                                                    flatbuffers::Offset<flatbuffers::String> registration_name = 0)
{
    TreeNodeBuilder builder_(_fbb);
    builder_.add_registration_name(registration_name);
    builder_.add_instance_name(instance_name);
    builder_.add_children_uid(children_uid);
    builder_.add_uid(uid);
    builder_.add_status(status);
    builder_.add_type(type);
    return builder_.Finish();
}

inline flatbuffers::Offset<TreeNode> CreateTreeNodeDirect(flatbuffers::FlatBufferBuilder& _fbb, uint16_t uid = 0,
                                                          const std::vector<uint16_t>* children_uid = nullptr,
                                                          Type type = Type::UNDEFINED, Status status = Status::IDLE,
                                                          const char* instance_name = nullptr,
                                                          const char* registration_name = nullptr)
{
    return BT_Serialization::CreateTreeNode(_fbb, uid, children_uid ? _fbb.CreateVector<uint16_t>(*children_uid) : 0,
                                            type, status, instance_name ? _fbb.CreateString(instance_name) : 0,
                                            registration_name ? _fbb.CreateString(registration_name) : 0);
}

struct BehaviorTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
    enum
    {
        VT_ROOT_UID = 4,
        VT_NODES = 6
    };
    uint16_t root_uid() const
    {
        return GetField<uint16_t>(VT_ROOT_UID, 0);
    }
    const flatbuffers::Vector<flatbuffers::Offset<TreeNode>>* nodes() const
    {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TreeNode>>*>(VT_NODES);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_ROOT_UID) &&
               VerifyOffset(verifier, VT_NODES) && verifier.Verify(nodes()) && verifier.VerifyVectorOfTables(nodes()) &&
               verifier.EndTable();
    }
};

struct BehaviorTreeBuilder
{
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_root_uid(uint16_t root_uid)
    {
        fbb_.AddElement<uint16_t>(BehaviorTree::VT_ROOT_UID, root_uid, 0);
    }
    void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> nodes)
    {
        fbb_.AddOffset(BehaviorTree::VT_NODES, nodes);
    }
    explicit BehaviorTreeBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    BehaviorTreeBuilder& operator=(const BehaviorTreeBuilder&);
    flatbuffers::Offset<BehaviorTree> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<BehaviorTree>(end);
        return o;
    }
};

inline flatbuffers::Offset<BehaviorTree>
CreateBehaviorTree(flatbuffers::FlatBufferBuilder& _fbb, uint16_t root_uid = 0,
                   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> nodes = 0)
{
    BehaviorTreeBuilder builder_(_fbb);
    builder_.add_nodes(nodes);
    builder_.add_root_uid(root_uid);
    return builder_.Finish();
}

inline flatbuffers::Offset<BehaviorTree>
CreateBehaviorTreeDirect(flatbuffers::FlatBufferBuilder& _fbb, uint16_t root_uid = 0,
                         const std::vector<flatbuffers::Offset<TreeNode>>* nodes = nullptr)
{
    return BT_Serialization::CreateBehaviorTree(_fbb, root_uid,
                                                nodes ? _fbb.CreateVector<flatbuffers::Offset<TreeNode>>(*nodes) : 0);
}

struct StatusChangeLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
    enum
    {
        VT_BEHAVIOR_TREE = 4,
        VT_STATE_CHANGES = 6
    };
    const BehaviorTree* behavior_tree() const
    {
        return GetPointer<const BehaviorTree*>(VT_BEHAVIOR_TREE);
    }
    const flatbuffers::Vector<const StatusChange*>* state_changes() const
    {
        return GetPointer<const flatbuffers::Vector<const StatusChange*>*>(VT_STATE_CHANGES);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BEHAVIOR_TREE) &&
               verifier.VerifyTable(behavior_tree()) && VerifyOffset(verifier, VT_STATE_CHANGES) &&
               verifier.Verify(state_changes()) && verifier.EndTable();
    }
};

struct StatusChangeLogBuilder
{
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_behavior_tree(flatbuffers::Offset<BehaviorTree> behavior_tree)
    {
        fbb_.AddOffset(StatusChangeLog::VT_BEHAVIOR_TREE, behavior_tree);
    }
    void add_state_changes(flatbuffers::Offset<flatbuffers::Vector<const StatusChange*>> state_changes)
    {
        fbb_.AddOffset(StatusChangeLog::VT_STATE_CHANGES, state_changes);
    }
    explicit StatusChangeLogBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    StatusChangeLogBuilder& operator=(const StatusChangeLogBuilder&);
    flatbuffers::Offset<StatusChangeLog> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<StatusChangeLog>(end);
        return o;
    }
};

inline flatbuffers::Offset<StatusChangeLog>
CreateStatusChangeLog(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<BehaviorTree> behavior_tree = 0,
                      flatbuffers::Offset<flatbuffers::Vector<const StatusChange*>> state_changes = 0)
{
    StatusChangeLogBuilder builder_(_fbb);
    builder_.add_state_changes(state_changes);
    builder_.add_behavior_tree(behavior_tree);
    return builder_.Finish();
}

inline flatbuffers::Offset<StatusChangeLog>
CreateStatusChangeLogDirect(flatbuffers::FlatBufferBuilder& _fbb, flatbuffers::Offset<BehaviorTree> behavior_tree = 0,
                            const std::vector<StatusChange>* state_changes = nullptr)
{
    return BT_Serialization::CreateStatusChangeLog(
        _fbb, behavior_tree, state_changes ? _fbb.CreateVectorOfStructs<StatusChange>(*state_changes) : 0);
}

inline const BT_Serialization::BehaviorTree* GetBehaviorTree(const void* buf)
{
    return flatbuffers::GetRoot<BT_Serialization::BehaviorTree>(buf);
}

inline const BT_Serialization::BehaviorTree* GetSizePrefixedBehaviorTree(const void* buf)
{
    return flatbuffers::GetSizePrefixedRoot<BT_Serialization::BehaviorTree>(buf);
}

inline bool VerifyBehaviorTreeBuffer(flatbuffers::Verifier& verifier)
{
    return verifier.VerifyBuffer<BT_Serialization::BehaviorTree>(nullptr);
}

inline bool VerifySizePrefixedBehaviorTreeBuffer(flatbuffers::Verifier& verifier)
{
    return verifier.VerifySizePrefixedBuffer<BT_Serialization::BehaviorTree>(nullptr);
}

inline void FinishBehaviorTreeBuffer(flatbuffers::FlatBufferBuilder& fbb,
                                     flatbuffers::Offset<BT_Serialization::BehaviorTree> root)
{
    fbb.Finish(root);
}

inline void FinishSizePrefixedBehaviorTreeBuffer(flatbuffers::FlatBufferBuilder& fbb,
                                                 flatbuffers::Offset<BT_Serialization::BehaviorTree> root)
{
    fbb.FinishSizePrefixed(root);
}

}   // namespace BT_Serialization

#endif   // FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_
