{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home About this library This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions. What is a Behavior Tree? A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes. \"Ok, but WHY do we need BehaviorTrees (or FSM)?\" Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Based Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently, the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#about-this-library","text":"This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly you custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions.","title":"About this library"},{"location":"#what-is-a-behavior-tree","text":"A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"What is a Behavior Tree?"},{"location":"#ok-but-why-do-we-need-behaviortrees-or-fsm","text":"Many software systems, being robotics a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Based Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently, the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"\"Ok, but WHY do we need BehaviorTrees (or FSM)?\""},{"location":"BT_basics/","text":"Introduction to BTs Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, i.e. the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that communicates with the \"server\" that performs the operation. In the following example, we can see two Actions executed in a sequence, DetectObject and GraspObject . The other nodes of the tree, those which are not leaves , control the \"flow of execution\". To better understand how this control flow takes place, imagine a signal called \" tick \"; it is executed at the root of the tree and it propagates through the branches until it reaches one or multiple leaves. Note The word tick will be often used as a verb (to tick / to be ticked) and it means \"To invoke the callback tick() of a TreeNode \". When a TreeNode is ticked, it returns a NodeStatus that can be either: SUCCESS FAILURE RUNNING The first two, as their names suggests, inform their parent that their operation was a success or a failure. RUNNING is returned by asynchronous nodes when their execution is not completed and they needs more time to return a valid result. Asynchronous nodes can be halted . The result of a node is propagated back to its parent, that will decide which child should be ticked next or may return a result to its own parent. Types of nodes ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes are similar to the ControlNode, but can only have a single child. ActionNodes are leaves and do not have any children. The user should implement their own ActionNodes to perform the actual tasks. ConditionNodes are equivalent to ActionNodes, but they are always atomic and synchronous, i.e. they must not return RUNNING. They should not alter the state of the system. Examples To better understand how BehaviorTrees work, let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously. First ControlNode: Sequence Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . The children of a ControlNode are always ordered ; in the graphical representation, the order of execution is from left to right . In short: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Sequence returns SUCCESS too. Have you spotted the bug? If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseFridge is skipped. Decorators Depending on the type of DecoratorNode , the goal of this node could be either: to transform the result it received from the child to halt the execution of the child, to repeat ticking the child, depending on the type of Decorator. You can extend your grammar creating your own Decorators. The node Inverter is a Decorator that inverts the result returned by its child; An Inverter followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But... Have you spotted the bug? If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. We will see later how we can improve this tree. Second ControlNode: Fallback FallbackNodes , known also as \"Selectors\" , are nodes that can express, as the name suggests, fallback strategies, i.e. what to do next if a child returns FAILURE. It ticks the children in order and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequences and Fallbacks can be combined: Is the door open? If not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room. \"Fetch me a beer\" revisited We can now improve the \"Fetch Me a Beer\" example, which left the door open if the beer was not inside the fridge. We use the color \"green\" to represent nodes which return SUCCESS and \"red\" for those which return FAILURE. Black nodes haven't been executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both these trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS, no matter if we have actually grabbed the beer. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. Everything works as expected if GrabBeer returns SUCCESS.","title":"Introduction to BT"},{"location":"BT_basics/#introduction-to-bts","text":"Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, i.e. the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that communicates with the \"server\" that performs the operation. In the following example, we can see two Actions executed in a sequence, DetectObject and GraspObject . The other nodes of the tree, those which are not leaves , control the \"flow of execution\". To better understand how this control flow takes place, imagine a signal called \" tick \"; it is executed at the root of the tree and it propagates through the branches until it reaches one or multiple leaves. Note The word tick will be often used as a verb (to tick / to be ticked) and it means \"To invoke the callback tick() of a TreeNode \". When a TreeNode is ticked, it returns a NodeStatus that can be either: SUCCESS FAILURE RUNNING The first two, as their names suggests, inform their parent that their operation was a success or a failure. RUNNING is returned by asynchronous nodes when their execution is not completed and they needs more time to return a valid result. Asynchronous nodes can be halted . The result of a node is propagated back to its parent, that will decide which child should be ticked next or may return a result to its own parent.","title":"Introduction to BTs"},{"location":"BT_basics/#types-of-nodes","text":"ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes are similar to the ControlNode, but can only have a single child. ActionNodes are leaves and do not have any children. The user should implement their own ActionNodes to perform the actual tasks. ConditionNodes are equivalent to ActionNodes, but they are always atomic and synchronous, i.e. they must not return RUNNING. They should not alter the state of the system.","title":"Types of nodes"},{"location":"BT_basics/#examples","text":"To better understand how BehaviorTrees work, let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously.","title":"Examples"},{"location":"BT_basics/#first-controlnode-sequence","text":"Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . The children of a ControlNode are always ordered ; in the graphical representation, the order of execution is from left to right . In short: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Sequence returns SUCCESS too. Have you spotted the bug? If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseFridge is skipped.","title":"First ControlNode: Sequence"},{"location":"BT_basics/#decorators","text":"Depending on the type of DecoratorNode , the goal of this node could be either: to transform the result it received from the child to halt the execution of the child, to repeat ticking the child, depending on the type of Decorator. You can extend your grammar creating your own Decorators. The node Inverter is a Decorator that inverts the result returned by its child; An Inverter followed by the node called DoorOpen is therefore equivalent to Is the door closed? . The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed, then try to open it. Try up to 3 times, otherwise give up and return FAILURE. But... Have you spotted the bug? If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. We will see later how we can improve this tree.","title":"Decorators"},{"location":"BT_basics/#second-controlnode-fallback","text":"FallbackNodes , known also as \"Selectors\" , are nodes that can express, as the name suggests, fallback strategies, i.e. what to do next if a child returns FAILURE. It ticks the children in order and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequences and Fallbacks can be combined: Is the door open? If not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room.","title":"Second ControlNode: Fallback"},{"location":"BT_basics/#fetch-me-a-beer-revisited","text":"We can now improve the \"Fetch Me a Beer\" example, which left the door open if the beer was not inside the fridge. We use the color \"green\" to represent nodes which return SUCCESS and \"red\" for those which return FAILURE. Black nodes haven't been executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both these trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS, no matter if we have actually grabbed the beer. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. Everything works as expected if GrabBeer returns SUCCESS.","title":"\"Fetch me a beer\" revisited"},{"location":"DecoratorNode/","text":"Decorators A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked. InverterNode Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too. ForceSuccessNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS. ForceFailureNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE. RepeatNode Tick the child up to N times, where N is passed as a Input Port , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too. RetryNode Tick the child up to N times, where N is passed as a Input Port , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"Decorators Nodes"},{"location":"DecoratorNode/#decorators","text":"A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked.","title":"Decorators"},{"location":"DecoratorNode/#inverternode","text":"Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too.","title":"InverterNode"},{"location":"DecoratorNode/#forcesuccessnode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS.","title":"ForceSuccessNode"},{"location":"DecoratorNode/#forcefailurenode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE.","title":"ForceFailureNode"},{"location":"DecoratorNode/#repeatnode","text":"Tick the child up to N times, where N is passed as a Input Port , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too.","title":"RepeatNode"},{"location":"DecoratorNode/#retrynode","text":"Tick the child up to N times, where N is passed as a Input Port , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"RetryNode"},{"location":"FallbackNode/","text":"Fallback This family of nodes are known as \"Selector\" or \"Priority\" in other frameworks. Their purpose is to try different strategies, until we find one that \"works\". They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns FAILURE , the fallback ticks the next child. If the last child returns FAILURE too, all the children are halted and the sequence returns FAILURE . If a child returns SUCCESS , it stops and returns SUCCESS . All the children are halted. The two versions of Fallback differ in the way they react when a child returns RUNNING: FallbackStar will return RUNNING and the next time it is ticked, it will tick the same child where it left off before. Plain old Fallback will return RUNNING and the index of the next child to execute is reset after each execution. Fallback In this example, we try different strategies to open the door. Check first (and once) if the door is open. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( _index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, _index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop _index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. HaltAllChildren (); _index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ; ReactiveFallback This ControlNode is used when you want to interrupt an asynchronous child if one of the previous Conditions changes its state from FAILURE to SUCCESS. In the following example, character will sleep up to 8 hours or less, if he/she is fully rested. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // At the next tick, index will be the same. HaltAllChildren (); index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ;","title":"Fallback Nodes"},{"location":"FallbackNode/#fallback","text":"This family of nodes are known as \"Selector\" or \"Priority\" in other frameworks. Their purpose is to try different strategies, until we find one that \"works\". They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns FAILURE , the fallback ticks the next child. If the last child returns FAILURE too, all the children are halted and the sequence returns FAILURE . If a child returns SUCCESS , it stops and returns SUCCESS . All the children are halted. The two versions of Fallback differ in the way they react when a child returns RUNNING: FallbackStar will return RUNNING and the next time it is ticked, it will tick the same child where it left off before. Plain old Fallback will return RUNNING and the index of the next child to execute is reset after each execution.","title":"Fallback"},{"location":"FallbackNode/#fallback_1","text":"In this example, we try different strategies to open the door. Check first (and once) if the door is open. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( _index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, _index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop _index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. HaltAllChildren (); _index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ;","title":"Fallback"},{"location":"FallbackNode/#reactivefallback","text":"This ControlNode is used when you want to interrupt an asynchronous child if one of the previous Conditions changes its state from FAILURE to SUCCESS. In the following example, character will sleep up to 8 hours or less, if he/she is fully rested. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. // At the next tick, index will be the same. HaltAllChildren (); index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ;","title":"ReactiveFallback"},{"location":"MigrationGuide/","text":"Migration Guide from V2 to V3 The main goal of this project is to create a Behavior Tree implementation that uses the principles of Model Driven Development to separate the role of the Component Developer from the Behavior Designer and System Integrator . In practice, this means that: Custom Actions (or, in general, custom TreeNodes) must be reusable building blocks. Implement them once, reuse them many times. To build a Behavior Tree out of TreeNodes, the Behavior Designer must not need to read nor modify the source code of the a given TreeNode. There was a major design flaw that undermined these goals in version 2.x : the way the BlackBoard was used to implement DataFlow between nodes. As described in issue #18 there are several potential problems with the Blackboard approach: To know which entries of the BB are read/written, you should read the source code. As a consequence, external tools such as Groot can not know which BB entries are accessed. If there is a name clashing (multiple nodes use the same key for different purposes), the only way to fit it is modifying the source code. SMACH solved this problem using input and output ports and remapping to connect them. In the ROS community, we potentially have the same problem with topics, but tools such as rosinfo provides introspection at run-time and name clashing is avoided using remapping. This was the main reason to develop version 3.x of Behaviortree.CPP , but we also took the opportunity to do some additional refactoring to make the code more understandable. In this document we will use the following terms quite often: Composition : it refers to \"composing\" TreeNodes into Trees. In general we want a TreeNode implementation to be composition-agnostic. Model/Modelling : it is a description of a Tree or TreeNode that is sufficient (and necessary) to describe it, without knowing any additional detail about the actual C++ implementation. Blackboard, NodeParameters an DataPorts In version 2.x we had the intuition that passing one or more arguments to a TreeNode would make the node more generic and reusable. This is similar to the arguments of a function in any programming language. // with arguments GoTo ( kitchen ) //Without arguments GoToKitchen () GoToLivingRoom () GoToBedRoom1 () GoToBedroom2 () // .... To pass NodeParameters we used the Blackboard, that is nothing more than a shared key/value table, i.e. a glorified bunch of global variables. The key is a string , whilst the value is stored in a type-safe container similar to std::any or std::variant . The problem is that writing/reading in an entry of the BB was done implicitly in the source code and it was usually hard-coded. This made the TreeNode not reusable. To fix this, we still use the Blackboard under the hood, but it can not be accessed directly anymore. In version 3.x Blackboard entries can be read/written using respectively InputPorts and OutputPorts . These ports must be defined explicitly to allow remapping at run-time. Let's take a look to an example writte using the old code: root BehaviorTree SequenceStar CalculateGoal/ MoveBase goal= ${GoalPose} / /SequenceStar /BehaviorTree /root using namespace BT ; //Old code (V2) NodeStatus CalculateGoal ( TreeNode self ) { const Pose2D mygoal = { 1 , 2 , 3.14 }; // GoalPose is hardcoded... we don t like that self . blackboard () - set ( GoalPose , mygoal ); return NodeStatus :: SUCCESS ; } class MoveBase : public AsyncActionNode { public : MoveBase ( const std :: string name , const NodeParameters params ) : AsyncActionNode ( name , params ) {} static const NodeParameters requiredNodeParameters () { static NodeParameters params = {{ goal , 0;0;0 }}; return params ; } NodeStatus tick () { Pose2D goal ; if ( getParam Pose2D ( goal , goal )) { printf ( [ MoveBase: DONE ] \\n ); return NodeStatus :: SUCCESS ; } else { printf ( MoveBase: Failed for some reason \\n ); return NodeStatus :: FAILURE ; } } /// etc. }; We may notice that the NodeParameter can be remapped in the XML, but to change the key \"GoalPose\" in CalculateGoalPose we must inspect the code and modify it. In other words, NodeParameter is already a reasonably good implementation of an InputPort , but we need to introduce a consistent OutputPort too. This is the new code: root BehaviorTree SequenceStar CalculateGoal target= {GoalPose} / MoveBase goal= {GoalPose} / /SequenceStar /BehaviorTree /root using namespace BT ; //New code (V3) class CalculateGoalPose : public SyncActionNode { public : MoveBase ( const std :: string name , const NodeConfiguration cfg ) : SyncActionNode ( name , cfg ) {} static PortsList providedPorts () { return { OutputPort Pose2D ( target ) }; } BT :: NodeStatus tick () { const Pose2D myTarget = { 1 , 2 , 3.14 }; setOutput ( target , myTarget ); return NodeStatus :: SUCCESS ; } }; class MoveBase : public AsyncActionNode { public : MoveBase ( const std :: string name , const NodeConfiguration config ) : AsyncActionNode ( name , config ) {} static PortsList providedPorts () { return { InputPort Pose2D ( goal , Port description , 0;0;0 ) }; } NodeStatus tick () { Pose2D goal ; if ( auto res = getInput Pose2D ( goal , goal )) { printf ( [ MoveBase: DONE ] \\n ); return NodeStatus :: SUCCESS ; } else { printf ( MoveBase: Failed. Error code: %s \\n , res . error ()); return NodeStatus :: FAILURE ; } } /// etc. }; The main differences are: requiredNodeParameters() was replaced by providedPorts() , that is used to declare both Inputs and Output ports alike. setOutput () has been introduced. The method blackboard() can not be accessed anymore. getParam () is now called getInput () to be more consistent with setOutput () . Furthermore, if an error occurs, we can get the error message. Remapping to a shared entry (\"GoalPose\") is done at run-time in the XML. You will never need to modify the C++ source code. SubTrees, remapping and isolated Blackboards Thanks to ports we solved the problem of reusability of single treeNodes . But we still need to address the problem of reusability of entire Trees/SubTrees . According to the rule of hierarchical composition , from the point of view of a parent Node if should not matter if the child is a LeafNode, a DecoratorNode a ControlNode or an entire Tree. As mentioned earlier, the Blackboard used to be a large key/value table. Unfortunately, this might be challenging when we reuse multiple SubTree, once again because of name clashing. The solution in version 3.x is to have a separated and isolated Blackboard for each Tree/Subtree. If we want to connect the \"internal\" ports of a SubTree with the other ports of the BB of the parent, we must explicitly do a remapping in the XML definition. No C++ code need to be modified. From the point of view of the XML, remapped ports of a SubTree looks exactly like the ports of a single node. For more details, refer to the example t06_subtree_port_remapping.cpp . ControlNodes renamed/refactored The principle of least astonishment applies to user interface and software design. A typical formulation of the principle, from 1984, is: \"If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature. In my opinion, the two main building blocks of BehaviorTree.CPP, the SequenceNode and the FallbackNode have a very high astonishment factor, because they are \"reactive\" . By \"reactive\" we mean that: Children (usually ConditionNodes ) that returned a valid value, such as SUCCESS or FAILURE, might be ticked again if another child returns RUNNING. A different result in that Condition might abort/halt the RUNNING asynchronous child. The main concern of the original author of this library was to build reactive Behavior Trees (see for reference this publication ). I share this goal, but I prefer to have more explicit names, because reactive ControlNodes are useful but hard to reason about sometimes. I don't think reactive ControlNodes should be used mindlessly by default. For instance, most of the time users I talked with should have used SequenceStar instead of Sequence in many cases. I renamed the ControlNodes as follows to reflect this reality: Old Name (v2) New name (v3) Is reactive? Sequence ReactiveSequence YES SequenceStar (reset_on_failure=true) Sequence NO SequenceStar (reset_on_failure=false) SequenceStar NO Fallback ReactiveFallback YES FallbackStar Fallback NO Parallel Parallel Yes(v2) / No(v3) A reactive ParallelNode was very confusing and error prone; in most cases, what you really want is you want to use a ReactiveSequence instead. In version 2.x it was unclear what would happen if a \"reactive\" node has more than a single asynchronous child. The new recommendation is: Reactive nodes should NOT have more than a single asynchronous child . This is a very opinionated decision and for this reason it is documented but not enforced by the implementation.","title":"Migrate from Version 2.X"},{"location":"MigrationGuide/#migration-guide-from-v2-to-v3","text":"The main goal of this project is to create a Behavior Tree implementation that uses the principles of Model Driven Development to separate the role of the Component Developer from the Behavior Designer and System Integrator . In practice, this means that: Custom Actions (or, in general, custom TreeNodes) must be reusable building blocks. Implement them once, reuse them many times. To build a Behavior Tree out of TreeNodes, the Behavior Designer must not need to read nor modify the source code of the a given TreeNode. There was a major design flaw that undermined these goals in version 2.x : the way the BlackBoard was used to implement DataFlow between nodes. As described in issue #18 there are several potential problems with the Blackboard approach: To know which entries of the BB are read/written, you should read the source code. As a consequence, external tools such as Groot can not know which BB entries are accessed. If there is a name clashing (multiple nodes use the same key for different purposes), the only way to fit it is modifying the source code. SMACH solved this problem using input and output ports and remapping to connect them. In the ROS community, we potentially have the same problem with topics, but tools such as rosinfo provides introspection at run-time and name clashing is avoided using remapping. This was the main reason to develop version 3.x of Behaviortree.CPP , but we also took the opportunity to do some additional refactoring to make the code more understandable. In this document we will use the following terms quite often: Composition : it refers to \"composing\" TreeNodes into Trees. In general we want a TreeNode implementation to be composition-agnostic. Model/Modelling : it is a description of a Tree or TreeNode that is sufficient (and necessary) to describe it, without knowing any additional detail about the actual C++ implementation.","title":"Migration Guide from V2 to V3"},{"location":"MigrationGuide/#blackboard-nodeparameters-an-dataports","text":"In version 2.x we had the intuition that passing one or more arguments to a TreeNode would make the node more generic and reusable. This is similar to the arguments of a function in any programming language. // with arguments GoTo ( kitchen ) //Without arguments GoToKitchen () GoToLivingRoom () GoToBedRoom1 () GoToBedroom2 () // .... To pass NodeParameters we used the Blackboard, that is nothing more than a shared key/value table, i.e. a glorified bunch of global variables. The key is a string , whilst the value is stored in a type-safe container similar to std::any or std::variant . The problem is that writing/reading in an entry of the BB was done implicitly in the source code and it was usually hard-coded. This made the TreeNode not reusable. To fix this, we still use the Blackboard under the hood, but it can not be accessed directly anymore. In version 3.x Blackboard entries can be read/written using respectively InputPorts and OutputPorts . These ports must be defined explicitly to allow remapping at run-time. Let's take a look to an example writte using the old code: root BehaviorTree SequenceStar CalculateGoal/ MoveBase goal= ${GoalPose} / /SequenceStar /BehaviorTree /root using namespace BT ; //Old code (V2) NodeStatus CalculateGoal ( TreeNode self ) { const Pose2D mygoal = { 1 , 2 , 3.14 }; // GoalPose is hardcoded... we don t like that self . blackboard () - set ( GoalPose , mygoal ); return NodeStatus :: SUCCESS ; } class MoveBase : public AsyncActionNode { public : MoveBase ( const std :: string name , const NodeParameters params ) : AsyncActionNode ( name , params ) {} static const NodeParameters requiredNodeParameters () { static NodeParameters params = {{ goal , 0;0;0 }}; return params ; } NodeStatus tick () { Pose2D goal ; if ( getParam Pose2D ( goal , goal )) { printf ( [ MoveBase: DONE ] \\n ); return NodeStatus :: SUCCESS ; } else { printf ( MoveBase: Failed for some reason \\n ); return NodeStatus :: FAILURE ; } } /// etc. }; We may notice that the NodeParameter can be remapped in the XML, but to change the key \"GoalPose\" in CalculateGoalPose we must inspect the code and modify it. In other words, NodeParameter is already a reasonably good implementation of an InputPort , but we need to introduce a consistent OutputPort too. This is the new code: root BehaviorTree SequenceStar CalculateGoal target= {GoalPose} / MoveBase goal= {GoalPose} / /SequenceStar /BehaviorTree /root using namespace BT ; //New code (V3) class CalculateGoalPose : public SyncActionNode { public : MoveBase ( const std :: string name , const NodeConfiguration cfg ) : SyncActionNode ( name , cfg ) {} static PortsList providedPorts () { return { OutputPort Pose2D ( target ) }; } BT :: NodeStatus tick () { const Pose2D myTarget = { 1 , 2 , 3.14 }; setOutput ( target , myTarget ); return NodeStatus :: SUCCESS ; } }; class MoveBase : public AsyncActionNode { public : MoveBase ( const std :: string name , const NodeConfiguration config ) : AsyncActionNode ( name , config ) {} static PortsList providedPorts () { return { InputPort Pose2D ( goal , Port description , 0;0;0 ) }; } NodeStatus tick () { Pose2D goal ; if ( auto res = getInput Pose2D ( goal , goal )) { printf ( [ MoveBase: DONE ] \\n ); return NodeStatus :: SUCCESS ; } else { printf ( MoveBase: Failed. Error code: %s \\n , res . error ()); return NodeStatus :: FAILURE ; } } /// etc. }; The main differences are: requiredNodeParameters() was replaced by providedPorts() , that is used to declare both Inputs and Output ports alike. setOutput () has been introduced. The method blackboard() can not be accessed anymore. getParam () is now called getInput () to be more consistent with setOutput () . Furthermore, if an error occurs, we can get the error message. Remapping to a shared entry (\"GoalPose\") is done at run-time in the XML. You will never need to modify the C++ source code.","title":"Blackboard, NodeParameters an DataPorts"},{"location":"MigrationGuide/#subtrees-remapping-and-isolated-blackboards","text":"Thanks to ports we solved the problem of reusability of single treeNodes . But we still need to address the problem of reusability of entire Trees/SubTrees . According to the rule of hierarchical composition , from the point of view of a parent Node if should not matter if the child is a LeafNode, a DecoratorNode a ControlNode or an entire Tree. As mentioned earlier, the Blackboard used to be a large key/value table. Unfortunately, this might be challenging when we reuse multiple SubTree, once again because of name clashing. The solution in version 3.x is to have a separated and isolated Blackboard for each Tree/Subtree. If we want to connect the \"internal\" ports of a SubTree with the other ports of the BB of the parent, we must explicitly do a remapping in the XML definition. No C++ code need to be modified. From the point of view of the XML, remapped ports of a SubTree looks exactly like the ports of a single node. For more details, refer to the example t06_subtree_port_remapping.cpp .","title":"SubTrees, remapping and isolated Blackboards"},{"location":"MigrationGuide/#controlnodes-renamedrefactored","text":"The principle of least astonishment applies to user interface and software design. A typical formulation of the principle, from 1984, is: \"If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature. In my opinion, the two main building blocks of BehaviorTree.CPP, the SequenceNode and the FallbackNode have a very high astonishment factor, because they are \"reactive\" . By \"reactive\" we mean that: Children (usually ConditionNodes ) that returned a valid value, such as SUCCESS or FAILURE, might be ticked again if another child returns RUNNING. A different result in that Condition might abort/halt the RUNNING asynchronous child. The main concern of the original author of this library was to build reactive Behavior Trees (see for reference this publication ). I share this goal, but I prefer to have more explicit names, because reactive ControlNodes are useful but hard to reason about sometimes. I don't think reactive ControlNodes should be used mindlessly by default. For instance, most of the time users I talked with should have used SequenceStar instead of Sequence in many cases. I renamed the ControlNodes as follows to reflect this reality: Old Name (v2) New name (v3) Is reactive? Sequence ReactiveSequence YES SequenceStar (reset_on_failure=true) Sequence NO SequenceStar (reset_on_failure=false) SequenceStar NO Fallback ReactiveFallback YES FallbackStar Fallback NO Parallel Parallel Yes(v2) / No(v3) A reactive ParallelNode was very confusing and error prone; in most cases, what you really want is you want to use a ReactiveSequence instead. In version 2.x it was unclear what would happen if a \"reactive\" node has more than a single asynchronous child. The new recommendation is: Reactive nodes should NOT have more than a single asynchronous child . This is a very opinionated decision and for this reason it is documented but not enforced by the implementation.","title":"ControlNodes renamed/refactored"},{"location":"SequenceNode/","text":"Sequences A Sequence ticks all it's children as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Currently the framework provides three kinds of nodes: Sequence SequenceStar ReactiveSequence They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . To understand how the three ControlNodes differ, refer to the following table: Type of ControlNode Child returns FAILURE Child returns RUNNING Sequence Restart Tick again ReactiveSequence Restart Restart SequenceStar Tick again Tick again \" Restart \" means that the entire sequence is restarted from the first child of the list. \" Tick again \" means that the next time the sequence is ticked, the same child is ticked again. Previous sibling, which returned SUCCESS already, are not ticked again. Sequence This tree represents the behavior of a sniper in a computer game. See the pseudocode status = RUNNING ; // _index is a private member while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == SUCCESS ) { _index ++ ; } else if ( child_status == RUNNING ) { // keep same index return RUNNING ; } else if ( child_status == FAILURE ) { HaltAllChildren (); _index = 0 ; return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); _index = 0 ; return SUCCESS ; ReactiveSequence This node is particularly useful to continuously check Conditions; but the user should also be careful when using asynchronous children, to be sure that thy are not ticked more often that expected. Let's take a look at another example: ApproachEnemy is an asynchronous action that returns RUNNING until it is, eventually, completed. The condition isEnemyVisible will be called many times and, if it becomes false (i,e, \"FAILURE\"), ApproachEnemy is halted. See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { return RUNNING ; } else if ( child_status == FAILURE ) { HaltAllChildren (); return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); return SUCCESS ; SequenceStar Use this ControlNode when you don't want to tick children again that already returned SUCCESS. Example : This is a patrolling agent/robot that must visit locations A, B and C only once . If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK must be checked at every tick, for this reason its parent must be a ReactiveSequence . See the pseudocode status = RUNNING ; // _index is a private member while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == SUCCESS ) { _index ++ ; } else if ( child_status == RUNNING || child_status == FAILURE ) { // keep same index return child_status ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); _index = 0 ; return SUCCESS ;","title":"Sequence Nodes"},{"location":"SequenceNode/#sequences","text":"A Sequence ticks all it's children as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Currently the framework provides three kinds of nodes: Sequence SequenceStar ReactiveSequence They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . To understand how the three ControlNodes differ, refer to the following table: Type of ControlNode Child returns FAILURE Child returns RUNNING Sequence Restart Tick again ReactiveSequence Restart Restart SequenceStar Tick again Tick again \" Restart \" means that the entire sequence is restarted from the first child of the list. \" Tick again \" means that the next time the sequence is ticked, the same child is ticked again. Previous sibling, which returned SUCCESS already, are not ticked again.","title":"Sequences"},{"location":"SequenceNode/#sequence","text":"This tree represents the behavior of a sniper in a computer game. See the pseudocode status = RUNNING ; // _index is a private member while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == SUCCESS ) { _index ++ ; } else if ( child_status == RUNNING ) { // keep same index return RUNNING ; } else if ( child_status == FAILURE ) { HaltAllChildren (); _index = 0 ; return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); _index = 0 ; return SUCCESS ;","title":"Sequence"},{"location":"SequenceNode/#reactivesequence","text":"This node is particularly useful to continuously check Conditions; but the user should also be careful when using asynchronous children, to be sure that thy are not ticked more often that expected. Let's take a look at another example: ApproachEnemy is an asynchronous action that returns RUNNING until it is, eventually, completed. The condition isEnemyVisible will be called many times and, if it becomes false (i,e, \"FAILURE\"), ApproachEnemy is halted. See the pseudocode status = RUNNING ; for ( int index = 0 ; index number_of_children ; index ++ ) { child_status = child [ index ] - tick (); if ( child_status == RUNNING ) { return RUNNING ; } else if ( child_status == FAILURE ) { HaltAllChildren (); return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); return SUCCESS ;","title":"ReactiveSequence"},{"location":"SequenceNode/#sequencestar","text":"Use this ControlNode when you don't want to tick children again that already returned SUCCESS. Example : This is a patrolling agent/robot that must visit locations A, B and C only once . If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK must be checked at every tick, for this reason its parent must be a ReactiveSequence . See the pseudocode status = RUNNING ; // _index is a private member while ( index number_of_children ) { child_status = child [ index ] - tick (); if ( child_status == SUCCESS ) { _index ++ ; } else if ( child_status == RUNNING || child_status == FAILURE ) { // keep same index return child_status ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); _index = 0 ; return SUCCESS ;","title":"SequenceStar"},{"location":"getting_started/","text":"Getting started BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS or SmartSoft . You can statically link it into your application (for example a game). These are the main concepts which you need to understand first. Nodes vs Trees The user must create his/her own ActionNodes and ConditionNodes (LeafNodes); this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks which you need to compose a complex system. By definition, your custom Nodes are (or should be) highly reusable . But, at the beginning, some wrapping interfaces might be needed to adapt your legacy code. The tick() callbacks Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code . What this callback does is up to you. In most of the following tutorials, our Actions will simply print messages on console or sleep for a certain amount of time to simulate a long calculation. In production code, especially in Model Driven Development and Component Based Software Engineering, an Action/Condition would probably communicate to other components or services of the system. Inheritance vs dependency injection. To create a custom TreeNode, you should inherit from the proper class. For instance, to create your own synchronous Action, you should inherit from the class SyncActionNode . Alternatively, the library provides a mechanism to create a TreeNode passing a function pointer to a wrapper (dependency injection). This approach reduces the amount of boilerplate in your code; as a reference please look at the first tutorial and the one describing non intrusive integration with legacy code . Dataflow, Ports and Blackboard Ports are explained in detail in the second and third tutorials. For the time being, it is important to know that: A Blackboard is a key/value storage shared by all the Nodes of a Tree. Ports are a mechanism that Nodes can use to exchange information between each other. Ports are \"connected\" using the same key of the blackboard. The number, name and kind of ports of a Node must be known at compilation-time (C++); connections between ports are done at deployment-time (XML). Load trees at run-time using the XML format Despite the fact that the library is written in C++, trees themselves can be composed at run-time , more specifically, at deployment-time , since it is done only once at the beginning to instantiate the Tree. An XML format is described in details here .","title":"Getting started"},{"location":"getting_started/#getting-started","text":"BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS or SmartSoft . You can statically link it into your application (for example a game). These are the main concepts which you need to understand first.","title":"Getting started"},{"location":"getting_started/#nodes-vs-trees","text":"The user must create his/her own ActionNodes and ConditionNodes (LeafNodes); this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks which you need to compose a complex system. By definition, your custom Nodes are (or should be) highly reusable . But, at the beginning, some wrapping interfaces might be needed to adapt your legacy code.","title":"Nodes vs Trees"},{"location":"getting_started/#the-tick-callbacks","text":"Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code . What this callback does is up to you. In most of the following tutorials, our Actions will simply print messages on console or sleep for a certain amount of time to simulate a long calculation. In production code, especially in Model Driven Development and Component Based Software Engineering, an Action/Condition would probably communicate to other components or services of the system.","title":"The tick() callbacks"},{"location":"getting_started/#inheritance-vs-dependency-injection","text":"To create a custom TreeNode, you should inherit from the proper class. For instance, to create your own synchronous Action, you should inherit from the class SyncActionNode . Alternatively, the library provides a mechanism to create a TreeNode passing a function pointer to a wrapper (dependency injection). This approach reduces the amount of boilerplate in your code; as a reference please look at the first tutorial and the one describing non intrusive integration with legacy code .","title":"Inheritance vs dependency injection."},{"location":"getting_started/#dataflow-ports-and-blackboard","text":"Ports are explained in detail in the second and third tutorials. For the time being, it is important to know that: A Blackboard is a key/value storage shared by all the Nodes of a Tree. Ports are a mechanism that Nodes can use to exchange information between each other. Ports are \"connected\" using the same key of the blackboard. The number, name and kind of ports of a Node must be known at compilation-time (C++); connections between ports are done at deployment-time (XML).","title":"Dataflow, Ports and Blackboard"},{"location":"getting_started/#load-trees-at-run-time-using-the-xml-format","text":"Despite the fact that the library is written in C++, trees themselves can be composed at run-time , more specifically, at deployment-time , since it is done only once at the beginning to instantiate the Tree. An XML format is described in details here .","title":"Load trees at run-time using the XML format"},{"location":"tutorial_01_first_tree/","text":"How to create a BehaviorTree Behavior Trees, similar to State Machines, are nothing more than a mechanism to invoke callbacks at the right time under the right conditions. Further, we will use the words \"callback\" and \"tick\" interchangeably. What happens inside these callbacks is up to you. In this tutorial series, most of the time Actions will just print some information on console, but keep in mind that real \"production\" code would probably do something more complicated. How to create your own ActionNodes The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom SyncActionNode (synchronous action) // without ports. class ApproachObject : public BT :: SyncActionNode { public : ApproachObject ( const std :: string name ) : BT :: SyncActionNode ( name , {}) { } // You must override the virtual function tick() BT :: NodeStatus tick () override { std :: cout ApproachObject: this - name () std :: endl ; return BT :: NodeStatus :: SUCCESS ; } }; As you can see: Any instance of a TreeNode has a name . This identifier is meant to be human-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must always return a NodeStatus, i.e. RUNNING, SUCCESS or FAILURE. Alternatively, we can use dependecy injection to create a TreeNode given a function pointer (i.e. \"functor\"). The only requirement of the functor is to have either one of these signatures: BT :: NodeStatus myFunction () BT :: NodeStatus myFunction ( BT :: TreeNode self ) For example: using namespace BT ; // Simple function that return a NodeStatus BT :: NodeStatus CheckBattery () { std :: cout [ Battery: OK ] std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // We want to wrap into an ActionNode the methods open() and close() class GripperInterface { public : GripperInterface () : _open ( true ) {} NodeStatus open () { _open = true ; std :: cout GripperInterface::open std :: endl ; return NodeStatus :: SUCCESS ; } NodeStatus close () { std :: cout GripperInterface::close std :: endl ; _open = false ; return NodeStatus :: SUCCESS ; } private : bool _open ; // shared information }; We can build a SimpleActionNode from any of these functors: CheckBattery() GripperInterface::open() GripperInterface::close() Create a tree dynamically with an XML Let's consider the following XML file named my_tree.xml : root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Note You can find more details about the XML schema here . We must first register our custom TreeNodes into the BehaviorTreeFactory and then load the XML from file or text. The identifier used in the XML must coincide with those used to register the TreeNodes. The attribute \"name\" represents the name of the instance; it is optional. #include behaviortree_cpp/bt_factory.h // file that contains the custom nodes definitions #include dummy_nodes.h int main () { // We use the BehaviorTreeFactory to register our custom nodes BehaviorTreeFactory factory ; // Note: the name used to register should be the same used in the XML. using namespace DummyNodes ; // The recommended way to create a Node is through inheritance. factory . registerNodeType ApproachObject ( ApproachObject ); // Registering a SimpleActionNode using a function pointer. // you may also use C++11 lambdas instead of std::bind factory . registerSimpleCondition ( CheckBattery , std :: bind ( CheckBattery )); //You can also create SimpleActionNodes using methods of a class GripperInterface gripper ; factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gripper )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gripper )); // Trees are created at deployment-time (i.e. at run-time, but only // once at the beginning). // IMPORTANT: when the object tree goes out of scope, all the // TreeNodes are destroyed auto tree = factory . createTreeFromFile ( ./my_tree.xml ); // To execute a Tree you need to tick it. // The tick is propagated to the children based on the logic of the tree. // In this case, the entire sequence is executed, because all the children // of the Sequence return SUCCESS. tree . root_node - executeTick (); return 0 ; } /* Expected output: * [ Battery: OK ] GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Tutorial 1: Create a Tree"},{"location":"tutorial_01_first_tree/#how-to-create-a-behaviortree","text":"Behavior Trees, similar to State Machines, are nothing more than a mechanism to invoke callbacks at the right time under the right conditions. Further, we will use the words \"callback\" and \"tick\" interchangeably. What happens inside these callbacks is up to you. In this tutorial series, most of the time Actions will just print some information on console, but keep in mind that real \"production\" code would probably do something more complicated.","title":"How to create a BehaviorTree"},{"location":"tutorial_01_first_tree/#how-to-create-your-own-actionnodes","text":"The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom SyncActionNode (synchronous action) // without ports. class ApproachObject : public BT :: SyncActionNode { public : ApproachObject ( const std :: string name ) : BT :: SyncActionNode ( name , {}) { } // You must override the virtual function tick() BT :: NodeStatus tick () override { std :: cout ApproachObject: this - name () std :: endl ; return BT :: NodeStatus :: SUCCESS ; } }; As you can see: Any instance of a TreeNode has a name . This identifier is meant to be human-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must always return a NodeStatus, i.e. RUNNING, SUCCESS or FAILURE. Alternatively, we can use dependecy injection to create a TreeNode given a function pointer (i.e. \"functor\"). The only requirement of the functor is to have either one of these signatures: BT :: NodeStatus myFunction () BT :: NodeStatus myFunction ( BT :: TreeNode self ) For example: using namespace BT ; // Simple function that return a NodeStatus BT :: NodeStatus CheckBattery () { std :: cout [ Battery: OK ] std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // We want to wrap into an ActionNode the methods open() and close() class GripperInterface { public : GripperInterface () : _open ( true ) {} NodeStatus open () { _open = true ; std :: cout GripperInterface::open std :: endl ; return NodeStatus :: SUCCESS ; } NodeStatus close () { std :: cout GripperInterface::close std :: endl ; _open = false ; return NodeStatus :: SUCCESS ; } private : bool _open ; // shared information }; We can build a SimpleActionNode from any of these functors: CheckBattery() GripperInterface::open() GripperInterface::close()","title":"How to create your own ActionNodes"},{"location":"tutorial_01_first_tree/#create-a-tree-dynamically-with-an-xml","text":"Let's consider the following XML file named my_tree.xml : root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SayHello name= action_hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Note You can find more details about the XML schema here . We must first register our custom TreeNodes into the BehaviorTreeFactory and then load the XML from file or text. The identifier used in the XML must coincide with those used to register the TreeNodes. The attribute \"name\" represents the name of the instance; it is optional. #include behaviortree_cpp/bt_factory.h // file that contains the custom nodes definitions #include dummy_nodes.h int main () { // We use the BehaviorTreeFactory to register our custom nodes BehaviorTreeFactory factory ; // Note: the name used to register should be the same used in the XML. using namespace DummyNodes ; // The recommended way to create a Node is through inheritance. factory . registerNodeType ApproachObject ( ApproachObject ); // Registering a SimpleActionNode using a function pointer. // you may also use C++11 lambdas instead of std::bind factory . registerSimpleCondition ( CheckBattery , std :: bind ( CheckBattery )); //You can also create SimpleActionNodes using methods of a class GripperInterface gripper ; factory . registerSimpleAction ( OpenGripper , std :: bind ( GripperInterface :: open , gripper )); factory . registerSimpleAction ( CloseGripper , std :: bind ( GripperInterface :: close , gripper )); // Trees are created at deployment-time (i.e. at run-time, but only // once at the beginning). // IMPORTANT: when the object tree goes out of scope, all the // TreeNodes are destroyed auto tree = factory . createTreeFromFile ( ./my_tree.xml ); // To execute a Tree you need to tick it. // The tick is propagated to the children based on the logic of the tree. // In this case, the entire sequence is executed, because all the children // of the Sequence return SUCCESS. tree . root_node - executeTick (); return 0 ; } /* Expected output: * [ Battery: OK ] GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Create a tree dynamically with an XML"},{"location":"tutorial_02_basic_ports/","text":"Input and Output Ports As we explained earlier, custom TreeNodes can be used to execute an arbitrarily simple or complex piece of software. Their goal is to provide an interface with a higher level of abstraction . For this reason, they are not conceptually different from functions . Similar to functions, we often want to: pass arguments/parameters to a Node ( inputs ) get some kind of information out from a Node ( outputs ). The outputs of a node can be the inputs of another node. BehaviorTree.CPP provides a basic mechanism of dataflow through ports , that is simple to use but also flexible and type safe. Inputs ports A valid Input can be either: static strings which can be parsed by the Node, or \"pointers\" to an entry of the Blackboard, identified by a key . A \"blackboard\" is a simple key/value storage shared by all the nodes of the Tree. An \"entry\" of the Blackboard is a key/value pair . Input ports can read an entry in the Blackboard, whilst an Output port can write into an entry. Let's suppose that we want to create an ActionNode called SaySomething , that should print a given string on std::cout . Such a string will be passed using an input port called message . Consider these alternative XML syntaxes: SaySomething name= first message= hello world / SaySomething name= second message= {greetings} / The attribute message in the first node means: The static string hello world is passed to the port message of SaySomething . The message is read from the XML file, therefore it can not change at run-time. The syntax of the second node instead means: Read the current value in the entry of the blackboard called greetings . This value can (and probably will) change at run-time. The ActionNode SaySomething can be implemented as follows: // SyncActionNode (synchronous action) with an input port. class SaySomething : public SyncActionNode { public : // If your Node has ports, you must use this constructor signature SaySomething ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) { } // It is mandatory to define this static method. static PortsList providedPorts () { // This action has a single input port called message // Any port must have a name. The type is optional. return { InputPort std :: string ( message ) }; } // As usual, you must override the virtual function tick() NodeStatus tick () override { Optional std :: string msg = getInput std :: string ( message ); // Check if optional is valid. If not, throw its error if ( ! msg ) { throw BT :: RuntimeError ( missing required input [message]: , msg . error () ); } // use the method value() to extract the valid message. std :: cout Robot says: msg . value () std :: endl ; return NodeStatus :: SUCCESS ; } }; When a custom TreeNode has input and/or output ports, these ports must be declared in the static method: static MyCustomNode :: PortsList providedPorts (); The input from the port message can be read using the template method TreeNode::getInput T (key) . This method may fail for multiple reasons. It is up to the user to check the validity of the returned value and to decide what to do: Return NodeStatus::FAILURE ? Throw an exception? Use a different default value? Important It is always recommended to call the method getInput() inside the tick() , and not in the constructor of the class. The C++ code must not make any assumption about the nature of the input, which could be either static or dynamic. A dynamic input can change at run-time, for this reason it should be read periodically. Output ports An input port pointing to the entry of the blackboard will be valid only if another node have already wrritten \"something\" inside that same entry. ThinkWhatToSay is an example of Node that uses an output port to write a string into an entry. class ThinkWhatToSay : public SyncActionNode { public : ThinkWhatToSay ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) { } static PortsList providedPorts () { return { OutputPort std :: string ( text ) }; } // This Action writes a value into the port text NodeStatus tick () override { // the output may change at each tick(). Here we keep it simple. setOutput ( text , The answer is 42 ); return NodeStatus :: SUCCESS ; } }; Alternatively, most of the time for debugging purposes, it is possible to write a static value into an entry using the built-in Actions called SetBlackboard . SetBlackboard output_key= the_answer value= The answer is 42 / A complete example In this example, a Sequence of 5 Actions is executed: Actions 1 and 4 read the input message from a static string. Actions 3 and 5 read the input message from an entry in the blackboard called the_answer . Action 2 writes something into the entry of the blackboard called the_answer . SaySomething2 is a SimpleActionNode. root BehaviorTree Sequence name= root SaySomething message= start thinking... / ThinkWhatToSay text= {the_answer} / SaySomething message= {the_answer} / SaySomething2 message= SaySomething2 works too... / SaySomething2 message= {the_answer} / /Sequence /BehaviorTree /root The C++ code: int main () { BehaviorTreeFactory factory ; factory . registerNodeType SaySomething ( SaySomething ); factory . registerNodeType ThinkWhatToSay ( ThinkWhatToSay ); // SimpleActionNodes can not define their own method providedPorts(). // We should pass a PortsList explicitly if we want the Action to // be able to use getInput() or setOutput(); PortsList say_something_ports = { InputPort std :: string ( message ) }; factory . registerSimpleAction ( SaySomething2 , SaySomethingSimple , say_something_ports ); auto tree = factory . createTreeFromText ( xml_text ); tree . root_node - executeTick (); /* Expected output: Robot says: start thinking... Robot says: The answer is 42 Robot says: SaySomething2 works too... Robot says: The answer is 42 */ return 0 ; } We \"connect\" output ports to input ports using the same key ( the_aswer ); this means that they \"point\" to the same entry of the blackboard. These ports can be connected to each other because their type is the same, i.e. std::string .","title":"Tutorial 2: Basic Ports"},{"location":"tutorial_02_basic_ports/#input-and-output-ports","text":"As we explained earlier, custom TreeNodes can be used to execute an arbitrarily simple or complex piece of software. Their goal is to provide an interface with a higher level of abstraction . For this reason, they are not conceptually different from functions . Similar to functions, we often want to: pass arguments/parameters to a Node ( inputs ) get some kind of information out from a Node ( outputs ). The outputs of a node can be the inputs of another node. BehaviorTree.CPP provides a basic mechanism of dataflow through ports , that is simple to use but also flexible and type safe.","title":"Input and Output Ports"},{"location":"tutorial_02_basic_ports/#inputs-ports","text":"A valid Input can be either: static strings which can be parsed by the Node, or \"pointers\" to an entry of the Blackboard, identified by a key . A \"blackboard\" is a simple key/value storage shared by all the nodes of the Tree. An \"entry\" of the Blackboard is a key/value pair . Input ports can read an entry in the Blackboard, whilst an Output port can write into an entry. Let's suppose that we want to create an ActionNode called SaySomething , that should print a given string on std::cout . Such a string will be passed using an input port called message . Consider these alternative XML syntaxes: SaySomething name= first message= hello world / SaySomething name= second message= {greetings} / The attribute message in the first node means: The static string hello world is passed to the port message of SaySomething . The message is read from the XML file, therefore it can not change at run-time. The syntax of the second node instead means: Read the current value in the entry of the blackboard called greetings . This value can (and probably will) change at run-time. The ActionNode SaySomething can be implemented as follows: // SyncActionNode (synchronous action) with an input port. class SaySomething : public SyncActionNode { public : // If your Node has ports, you must use this constructor signature SaySomething ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) { } // It is mandatory to define this static method. static PortsList providedPorts () { // This action has a single input port called message // Any port must have a name. The type is optional. return { InputPort std :: string ( message ) }; } // As usual, you must override the virtual function tick() NodeStatus tick () override { Optional std :: string msg = getInput std :: string ( message ); // Check if optional is valid. If not, throw its error if ( ! msg ) { throw BT :: RuntimeError ( missing required input [message]: , msg . error () ); } // use the method value() to extract the valid message. std :: cout Robot says: msg . value () std :: endl ; return NodeStatus :: SUCCESS ; } }; When a custom TreeNode has input and/or output ports, these ports must be declared in the static method: static MyCustomNode :: PortsList providedPorts (); The input from the port message can be read using the template method TreeNode::getInput T (key) . This method may fail for multiple reasons. It is up to the user to check the validity of the returned value and to decide what to do: Return NodeStatus::FAILURE ? Throw an exception? Use a different default value? Important It is always recommended to call the method getInput() inside the tick() , and not in the constructor of the class. The C++ code must not make any assumption about the nature of the input, which could be either static or dynamic. A dynamic input can change at run-time, for this reason it should be read periodically.","title":"Inputs ports"},{"location":"tutorial_02_basic_ports/#output-ports","text":"An input port pointing to the entry of the blackboard will be valid only if another node have already wrritten \"something\" inside that same entry. ThinkWhatToSay is an example of Node that uses an output port to write a string into an entry. class ThinkWhatToSay : public SyncActionNode { public : ThinkWhatToSay ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) { } static PortsList providedPorts () { return { OutputPort std :: string ( text ) }; } // This Action writes a value into the port text NodeStatus tick () override { // the output may change at each tick(). Here we keep it simple. setOutput ( text , The answer is 42 ); return NodeStatus :: SUCCESS ; } }; Alternatively, most of the time for debugging purposes, it is possible to write a static value into an entry using the built-in Actions called SetBlackboard . SetBlackboard output_key= the_answer value= The answer is 42 /","title":"Output ports"},{"location":"tutorial_02_basic_ports/#a-complete-example","text":"In this example, a Sequence of 5 Actions is executed: Actions 1 and 4 read the input message from a static string. Actions 3 and 5 read the input message from an entry in the blackboard called the_answer . Action 2 writes something into the entry of the blackboard called the_answer . SaySomething2 is a SimpleActionNode. root BehaviorTree Sequence name= root SaySomething message= start thinking... / ThinkWhatToSay text= {the_answer} / SaySomething message= {the_answer} / SaySomething2 message= SaySomething2 works too... / SaySomething2 message= {the_answer} / /Sequence /BehaviorTree /root The C++ code: int main () { BehaviorTreeFactory factory ; factory . registerNodeType SaySomething ( SaySomething ); factory . registerNodeType ThinkWhatToSay ( ThinkWhatToSay ); // SimpleActionNodes can not define their own method providedPorts(). // We should pass a PortsList explicitly if we want the Action to // be able to use getInput() or setOutput(); PortsList say_something_ports = { InputPort std :: string ( message ) }; factory . registerSimpleAction ( SaySomething2 , SaySomethingSimple , say_something_ports ); auto tree = factory . createTreeFromText ( xml_text ); tree . root_node - executeTick (); /* Expected output: Robot says: start thinking... Robot says: The answer is 42 Robot says: SaySomething2 works too... Robot says: The answer is 42 */ return 0 ; } We \"connect\" output ports to input ports using the same key ( the_aswer ); this means that they \"point\" to the same entry of the blackboard. These ports can be connected to each other because their type is the same, i.e. std::string .","title":"A complete example"},{"location":"tutorial_03_generic_ports/","text":"Ports with generic types In the previous tutorials we introduced input and output ports, where the type of the port itself was a std::string . This is the easiest port type to deal with, because any parameter passed from the XML definition will be (obviously) a string. Next, we will describe how to use any generic C++ type in your code. Parsing a string BehaviorTree.CPP supports automatic conversion of strings into common types, such as int , long , double , bool , NodeStatus , etc. But user defined types can be supported easily as well. For instance: // We want to be able to use this custom type struct Position2D { double x ; double y ; }; To parse a string into a Position2D we should link to a template specialization of BT::convertFromString Position2D (StringView) . We can use any syntax we want; in this case, we simply separate two numbers with a semicolon . // Template specialization to converts a string to Position2D. namespace BT { template inline Position2D convertFromString ( StringView str ) { // The next line should be removed... printf ( Converting string: \\ %s \\ \\n , str . data () ); // We expect real numbers separated by semicolons auto parts = splitString ( str , ; ); if ( parts . size () != 2 ) { throw RuntimeError ( invalid input) ); } else { Position2D output ; output . x = convertFromString double ( parts [ 0 ]); output . y = convertFromString double ( parts [ 1 ]); return output ; } } } // end namespace BT About the previous code: StringView is just a C++11 version of std::string_view . You can pass either a std::string or a const char* . In production code, you would (obviously) remove the printf statement. The library provides a simple splitString function. Feel free to use another one, like boost::algorithm::split . Once we split the input into single numbers, we can reuse the specialization convertFromString double () . Example Similarly to the previous tutorial, we can create two custom Actions, one will write into a port and the other will read from a port. class CalculateGoal : public SyncActionNode { public : CalculateGoal ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) {} static PortsList providedPorts () { return { OutputPort Position2D ( goal ) }; } NodeStatus tick () override { Position2D mygoal = { 1.1 , 2.3 }; setOutput Position2D ( goal , mygoal ); return NodeStatus :: SUCCESS ; } }; class PrintTarget : public SyncActionNode { public : PrintTarget ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) {} static PortsList providedPorts () { // Optionally, a port can have a human readable description const char * description = Simply print the goal on console... ; return { InputPort Position2D ( target , description ) }; } NodeStatus tick () override { auto res = getInput Position2D ( target ); if ( ! res ) { throw RuntimeError ( error reading port [target]: , res . error ()); } Position2D target = res . value (); printf ( Target positions: [ %.1f, %.1f ] \\n , target . x , target . y ); return NodeStatus :: SUCCESS ; } }; We can now connect input/output ports as usual, pointing to the same entry of the Blackboard. The tree in the next example is a Sequence of 4 actions Store a value of Position2D in the entry \"GoalPosition\", using the action CalculateGoal . Call PrintTarget . The input \"target\" will be read from the Blackboard entry \"GoalPosition\". Use the built-in action SetBlackboard to write the key \"OtherGoal\". A conversion from string to Position2D will be done under the hood. Call PrintTarget again. The input \"target\" will be read from the Blackboard entry \"OtherGoal\". static const char * xml_text = R ( root main_tree_to_execute = MainTree BehaviorTree ID= MainTree SequenceStar name= root CalculateGoal goal= {GoalPosition} / PrintTarget target= {GoalPosition} / SetBlackboard output_key= OtherGoal value= -1;3 / PrintTarget target= {OtherGoal} / /SequenceStar /BehaviorTree /root ) ; int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerNodeType CalculateGoal ( CalculateGoal ); factory . registerNodeType PrintTarget ( PrintTarget ); auto tree = factory . createTreeFromText ( xml_text ); tree . root_node - executeTick (); /* Expected output: Target positions: [ 1.1, 2.3 ] Converting string: -1;3 Target positions: [ -1.0, 3.0 ] */ return 0 ; }","title":"Tutorial 3: Generic ports"},{"location":"tutorial_03_generic_ports/#ports-with-generic-types","text":"In the previous tutorials we introduced input and output ports, where the type of the port itself was a std::string . This is the easiest port type to deal with, because any parameter passed from the XML definition will be (obviously) a string. Next, we will describe how to use any generic C++ type in your code.","title":"Ports with generic types"},{"location":"tutorial_03_generic_ports/#parsing-a-string","text":"BehaviorTree.CPP supports automatic conversion of strings into common types, such as int , long , double , bool , NodeStatus , etc. But user defined types can be supported easily as well. For instance: // We want to be able to use this custom type struct Position2D { double x ; double y ; }; To parse a string into a Position2D we should link to a template specialization of BT::convertFromString Position2D (StringView) . We can use any syntax we want; in this case, we simply separate two numbers with a semicolon . // Template specialization to converts a string to Position2D. namespace BT { template inline Position2D convertFromString ( StringView str ) { // The next line should be removed... printf ( Converting string: \\ %s \\ \\n , str . data () ); // We expect real numbers separated by semicolons auto parts = splitString ( str , ; ); if ( parts . size () != 2 ) { throw RuntimeError ( invalid input) ); } else { Position2D output ; output . x = convertFromString double ( parts [ 0 ]); output . y = convertFromString double ( parts [ 1 ]); return output ; } } } // end namespace BT About the previous code: StringView is just a C++11 version of std::string_view . You can pass either a std::string or a const char* . In production code, you would (obviously) remove the printf statement. The library provides a simple splitString function. Feel free to use another one, like boost::algorithm::split . Once we split the input into single numbers, we can reuse the specialization convertFromString double () .","title":"Parsing a string"},{"location":"tutorial_03_generic_ports/#example","text":"Similarly to the previous tutorial, we can create two custom Actions, one will write into a port and the other will read from a port. class CalculateGoal : public SyncActionNode { public : CalculateGoal ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) {} static PortsList providedPorts () { return { OutputPort Position2D ( goal ) }; } NodeStatus tick () override { Position2D mygoal = { 1.1 , 2.3 }; setOutput Position2D ( goal , mygoal ); return NodeStatus :: SUCCESS ; } }; class PrintTarget : public SyncActionNode { public : PrintTarget ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) {} static PortsList providedPorts () { // Optionally, a port can have a human readable description const char * description = Simply print the goal on console... ; return { InputPort Position2D ( target , description ) }; } NodeStatus tick () override { auto res = getInput Position2D ( target ); if ( ! res ) { throw RuntimeError ( error reading port [target]: , res . error ()); } Position2D target = res . value (); printf ( Target positions: [ %.1f, %.1f ] \\n , target . x , target . y ); return NodeStatus :: SUCCESS ; } }; We can now connect input/output ports as usual, pointing to the same entry of the Blackboard. The tree in the next example is a Sequence of 4 actions Store a value of Position2D in the entry \"GoalPosition\", using the action CalculateGoal . Call PrintTarget . The input \"target\" will be read from the Blackboard entry \"GoalPosition\". Use the built-in action SetBlackboard to write the key \"OtherGoal\". A conversion from string to Position2D will be done under the hood. Call PrintTarget again. The input \"target\" will be read from the Blackboard entry \"OtherGoal\". static const char * xml_text = R ( root main_tree_to_execute = MainTree BehaviorTree ID= MainTree SequenceStar name= root CalculateGoal goal= {GoalPosition} / PrintTarget target= {GoalPosition} / SetBlackboard output_key= OtherGoal value= -1;3 / PrintTarget target= {OtherGoal} / /SequenceStar /BehaviorTree /root ) ; int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerNodeType CalculateGoal ( CalculateGoal ); factory . registerNodeType PrintTarget ( PrintTarget ); auto tree = factory . createTreeFromText ( xml_text ); tree . root_node - executeTick (); /* Expected output: Target positions: [ 1.1, 2.3 ] Converting string: -1;3 Target positions: [ -1.0, 3.0 ] */ return 0 ; }","title":"Example"},{"location":"tutorial_04_sequence_star/","text":"Sequences and AsyncActionNode The next example shows the difference between a SequenceNode and a ReactiveSequence . An Asynchornous Action has it's own thread. This allows the user to use blocking functions but to return the flow of execution to the tree. // Custom type struct Pose2D { double x , y , theta ; }; class MoveBaseAction : public AsyncActionNode { public : MoveBaseAction ( const std :: string name , const NodeConfiguration config ) : AsyncActionNode ( name , config ) { } static PortsList providedPorts () { return { InputPort Pose2D ( goal ) }; } NodeStatus tick () override ; // This overloaded method is used to stop the execution of this node. void halt () override { _halt_requested . store ( true ); } private : std :: atomic_bool _halt_requested ; }; //------------------------- NodeStatus MoveBaseAction :: tick () { Pose2D goal ; if ( ! getInput Pose2D ( goal , goal )) { throw RuntimeError ( missing required input [goal] ); } printf ( [ MoveBase: STARTED ]. goal: x=%.f y=%.1f theta=%.2f \\n , goal . x , goal . y , goal . theta ); _halt_requested . store ( false ); int count = 0 ; // Pretend that computing takes 250 milliseconds. // It is up to you to check periodicall _halt_requested and interrupt // this tick() if it is true. while ( ! _halt_requested count ++ 25 ) { SleepMS ( 10 ); } std :: cout [ MoveBase: FINISHED ] std :: endl ; return _halt_requested ? NodeStatus :: FAILURE : NodeStatus :: SUCCESS ; } The method MoveBaseAction::tick() is executed in a thread different from the main thread that invoked MoveBaseAction::executeTick() . You are responsible for the implementation of a valid halt() functionality. The user must also implement convertFromString Pose2D (StringView) , as shown in the previous tutorial. Sequence VS ReactiveSequence The following example should use a simple SequenceNode . root BehaviorTree Sequence BatteryOK/ SaySomething message= mission started... / MoveBase goal= 1;2;3 / SaySomething message= mission completed! / /Sequence /BehaviorTree /root int main () { using namespace DummyNodes ; BehaviorTreeFactory factory ; factory . registerSimpleCondition ( BatteryOK , std :: bind ( CheckBattery )); factory . registerNodeType MoveBaseAction ( MoveBase ); factory . registerNodeType SaySomething ( SaySomething ); auto tree = factory . createTreeFromText ( xml_text ); NodeStatus status ; std :: cout \\n --- 1st executeTick() --- std :: endl ; status = tree . root_node - executeTick (); SleepMS ( 150 ); std :: cout \\n --- 2nd executeTick() --- std :: endl ; status = tree . root_node - executeTick (); SleepMS ( 150 ); std :: cout \\n --- 3rd executeTick() --- std :: endl ; status = tree . root_node - executeTick (); std :: cout std :: endl ; return 0 ; } Expected output: --- 1st executeTick() --- [ Battery: OK ] Robot says: mission started... [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 --- 2nd executeTick() --- [ MoveBase: FINISHED ] --- 3rd executeTick() --- Robot says: mission completed! You may have noticed that when executeTick() was called, MoveBase returned RUNNING the 1st and 2nd time, and eventually SUCCESS the 3rd time. BatteryOK is executed only once. If we use a ReactiveSequence instead, when the child MoveBase returns RUNNING, the sequence is restarted and the condition BatteryOK is executed again . If, at any point, BatteryOK returned FAILURE , the MoveBase action would be interrupted ( halted , to be specific). root BehaviorTree ReactiveSequence BatteryOK/ SaySomething message= mission started... / MoveBase goal= 1;2;3 / SaySomething message= mission completed! / /ReactiveSequence /BehaviorTree /root Expected output: --- 1st executeTick() --- [ Battery: OK ] Robot says: mission started... [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 --- 2nd executeTick() --- [ Battery: OK ] [ MoveBase: FINISHED ] --- 3rd executeTick() --- [ Battery: OK ] Robot says: mission completed!","title":"Tutorial 4: Sequences"},{"location":"tutorial_04_sequence_star/#sequences-and-asyncactionnode","text":"The next example shows the difference between a SequenceNode and a ReactiveSequence . An Asynchornous Action has it's own thread. This allows the user to use blocking functions but to return the flow of execution to the tree. // Custom type struct Pose2D { double x , y , theta ; }; class MoveBaseAction : public AsyncActionNode { public : MoveBaseAction ( const std :: string name , const NodeConfiguration config ) : AsyncActionNode ( name , config ) { } static PortsList providedPorts () { return { InputPort Pose2D ( goal ) }; } NodeStatus tick () override ; // This overloaded method is used to stop the execution of this node. void halt () override { _halt_requested . store ( true ); } private : std :: atomic_bool _halt_requested ; }; //------------------------- NodeStatus MoveBaseAction :: tick () { Pose2D goal ; if ( ! getInput Pose2D ( goal , goal )) { throw RuntimeError ( missing required input [goal] ); } printf ( [ MoveBase: STARTED ]. goal: x=%.f y=%.1f theta=%.2f \\n , goal . x , goal . y , goal . theta ); _halt_requested . store ( false ); int count = 0 ; // Pretend that computing takes 250 milliseconds. // It is up to you to check periodicall _halt_requested and interrupt // this tick() if it is true. while ( ! _halt_requested count ++ 25 ) { SleepMS ( 10 ); } std :: cout [ MoveBase: FINISHED ] std :: endl ; return _halt_requested ? NodeStatus :: FAILURE : NodeStatus :: SUCCESS ; } The method MoveBaseAction::tick() is executed in a thread different from the main thread that invoked MoveBaseAction::executeTick() . You are responsible for the implementation of a valid halt() functionality. The user must also implement convertFromString Pose2D (StringView) , as shown in the previous tutorial.","title":"Sequences and AsyncActionNode"},{"location":"tutorial_04_sequence_star/#sequence-vs-reactivesequence","text":"The following example should use a simple SequenceNode . root BehaviorTree Sequence BatteryOK/ SaySomething message= mission started... / MoveBase goal= 1;2;3 / SaySomething message= mission completed! / /Sequence /BehaviorTree /root int main () { using namespace DummyNodes ; BehaviorTreeFactory factory ; factory . registerSimpleCondition ( BatteryOK , std :: bind ( CheckBattery )); factory . registerNodeType MoveBaseAction ( MoveBase ); factory . registerNodeType SaySomething ( SaySomething ); auto tree = factory . createTreeFromText ( xml_text ); NodeStatus status ; std :: cout \\n --- 1st executeTick() --- std :: endl ; status = tree . root_node - executeTick (); SleepMS ( 150 ); std :: cout \\n --- 2nd executeTick() --- std :: endl ; status = tree . root_node - executeTick (); SleepMS ( 150 ); std :: cout \\n --- 3rd executeTick() --- std :: endl ; status = tree . root_node - executeTick (); std :: cout std :: endl ; return 0 ; } Expected output: --- 1st executeTick() --- [ Battery: OK ] Robot says: mission started... [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 --- 2nd executeTick() --- [ MoveBase: FINISHED ] --- 3rd executeTick() --- Robot says: mission completed! You may have noticed that when executeTick() was called, MoveBase returned RUNNING the 1st and 2nd time, and eventually SUCCESS the 3rd time. BatteryOK is executed only once. If we use a ReactiveSequence instead, when the child MoveBase returns RUNNING, the sequence is restarted and the condition BatteryOK is executed again . If, at any point, BatteryOK returned FAILURE , the MoveBase action would be interrupted ( halted , to be specific). root BehaviorTree ReactiveSequence BatteryOK/ SaySomething message= mission started... / MoveBase goal= 1;2;3 / SaySomething message= mission completed! / /ReactiveSequence /BehaviorTree /root Expected output: --- 1st executeTick() --- [ Battery: OK ] Robot says: mission started... [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 --- 2nd executeTick() --- [ Battery: OK ] [ MoveBase: FINISHED ] --- 3rd executeTick() --- [ Battery: OK ] Robot says: mission completed!","title":"Sequence VS ReactiveSequence"},{"location":"tutorial_05_subtrees/","text":"Composition of Behaviors with Subtree We can build large scale behavior composing together smaller and reusable behaviors into larger ones. In other words, we want to create hierarchical behavior trees. This can be achieved easily defining multiple trees in the XML including one into the other. CrossDoor behavior This example is inspired by a popular article about behavior trees . It is also the first practical example that uses Decorators and Fallback . root main_tree_to_execute = MainTree BehaviorTree ID= DoorClosed Sequence name= door_closed_sequence Inverter IsDoorOpen/ /Inverter RetryUntilSuccesful num_attempts= 4 OpenDoor/ /RetryUntilSuccesful PassThroughDoor/ /Sequence /BehaviorTree BehaviorTree ID= MainTree Fallback name= root_Fallback Sequence name= door_open_sequence IsDoorOpen/ PassThroughDoor/ /Sequence SubTree ID= DoorClosed / PassThroughWindow/ /Fallback /BehaviorTree /root It may be noticed that we incapsulated a quite complex branch of the tree, the one to execute when the door is closed, into a separate tree called DoorClosed . The desired behavior is: If the door is open, PassThroughDoor . If the door is closed, try up to 4 times to OpenDoor and, then, PassThroughDoor . If it was not possible to open the closed door, PassThroughWindow . Loggers On the C++ side we don't need to do anything to build reusable subtrees. Therefore we take this opportunity to introduce another neat feature of BehaviorTree.CPP : Loggers . A Logger is a mechanism to display, record and/or publish any state change in the tree. int main () { using namespace BT ; BehaviorTreeFactory factory ; // register all the actions into the factory // We don t show how these actions are implemented, since most of the // times they just print a message on screen and return SUCCESS. // See the code on Github for more details. factory . registerSimpleCondition ( IsDoorOpen , std :: bind ( IsDoorOpen )); factory . registerSimpleAction ( PassThroughDoor , std :: bind ( PassThroughDoor )); factory . registerSimpleAction ( PassThroughWindow , std :: bind ( PassThroughWindow )); factory . registerSimpleAction ( OpenDoor , std :: bind ( OpenDoor )); factory . registerSimpleAction ( CloseDoor , std :: bind ( CloseDoor )); factory . registerSimpleCondition ( IsDoorLocked , std :: bind ( IsDoorLocked )); factory . registerSimpleAction ( UnlockDoor , std :: bind ( UnlockDoor )); // Load from text or file... auto tree = factory . createTreeFromText ( xml_text ); // This logger prints state changes on console StdCoutLogger logger_cout ( tree . root_node ); // This logger saves state changes on file FileLogger logger_file ( tree . root_node , bt_trace.fbl ); // This logger stores the execution time of each node MinitraceLogger logger_minitrace ( tree . root_node , bt_trace.json ); printTreeRecursively ( tree . root_node ); //while (1) { NodeStatus status = NodeStatus :: RUNNING ; // Keep on ticking until you get either a SUCCESS or FAILURE state while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); CrossDoor :: SleepMS ( 1 ); // optional sleep to avoid busy loops } CrossDoor :: SleepMS ( 2000 ); } return 0 ; }","title":"Tutorial 5: Subtrees and Loggers"},{"location":"tutorial_05_subtrees/#composition-of-behaviors-with-subtree","text":"We can build large scale behavior composing together smaller and reusable behaviors into larger ones. In other words, we want to create hierarchical behavior trees. This can be achieved easily defining multiple trees in the XML including one into the other.","title":"Composition of Behaviors with Subtree"},{"location":"tutorial_05_subtrees/#crossdoor-behavior","text":"This example is inspired by a popular article about behavior trees . It is also the first practical example that uses Decorators and Fallback . root main_tree_to_execute = MainTree BehaviorTree ID= DoorClosed Sequence name= door_closed_sequence Inverter IsDoorOpen/ /Inverter RetryUntilSuccesful num_attempts= 4 OpenDoor/ /RetryUntilSuccesful PassThroughDoor/ /Sequence /BehaviorTree BehaviorTree ID= MainTree Fallback name= root_Fallback Sequence name= door_open_sequence IsDoorOpen/ PassThroughDoor/ /Sequence SubTree ID= DoorClosed / PassThroughWindow/ /Fallback /BehaviorTree /root It may be noticed that we incapsulated a quite complex branch of the tree, the one to execute when the door is closed, into a separate tree called DoorClosed . The desired behavior is: If the door is open, PassThroughDoor . If the door is closed, try up to 4 times to OpenDoor and, then, PassThroughDoor . If it was not possible to open the closed door, PassThroughWindow .","title":"CrossDoor behavior"},{"location":"tutorial_05_subtrees/#loggers","text":"On the C++ side we don't need to do anything to build reusable subtrees. Therefore we take this opportunity to introduce another neat feature of BehaviorTree.CPP : Loggers . A Logger is a mechanism to display, record and/or publish any state change in the tree. int main () { using namespace BT ; BehaviorTreeFactory factory ; // register all the actions into the factory // We don t show how these actions are implemented, since most of the // times they just print a message on screen and return SUCCESS. // See the code on Github for more details. factory . registerSimpleCondition ( IsDoorOpen , std :: bind ( IsDoorOpen )); factory . registerSimpleAction ( PassThroughDoor , std :: bind ( PassThroughDoor )); factory . registerSimpleAction ( PassThroughWindow , std :: bind ( PassThroughWindow )); factory . registerSimpleAction ( OpenDoor , std :: bind ( OpenDoor )); factory . registerSimpleAction ( CloseDoor , std :: bind ( CloseDoor )); factory . registerSimpleCondition ( IsDoorLocked , std :: bind ( IsDoorLocked )); factory . registerSimpleAction ( UnlockDoor , std :: bind ( UnlockDoor )); // Load from text or file... auto tree = factory . createTreeFromText ( xml_text ); // This logger prints state changes on console StdCoutLogger logger_cout ( tree . root_node ); // This logger saves state changes on file FileLogger logger_file ( tree . root_node , bt_trace.fbl ); // This logger stores the execution time of each node MinitraceLogger logger_minitrace ( tree . root_node , bt_trace.json ); printTreeRecursively ( tree . root_node ); //while (1) { NodeStatus status = NodeStatus :: RUNNING ; // Keep on ticking until you get either a SUCCESS or FAILURE state while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); CrossDoor :: SleepMS ( 1 ); // optional sleep to avoid busy loops } CrossDoor :: SleepMS ( 2000 ); } return 0 ; }","title":"Loggers"},{"location":"tutorial_06_subtree_ports/","text":"Remapping ports between Trees and SubTrees In the CrossDoor example we saw that a SubTree looks like a single leaf Node from the point of view of its parent ( MainTree in the example). Furthermore, to avoid name clashing in very large trees, any tree and subtree use a different instance of the Blackboard. For this reason, we need to explicitly connect the ports of a tree to those of its subtrees. Once again, you won't need to modify your C++ implementation since this remapping is done entirely in the XML definition. Example Let's consider this Beahavior Tree. root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= main_sequence SetBlackboard output_key= move_goal value= 1;2;3 / SubTree ID= MoveRobot target= move_goal output= move_result / SaySomething message= {move_result} / /Sequence /BehaviorTree BehaviorTree ID= MoveRobot Fallback name= move_robot_main SequenceStar MoveBase goal= {target} / SetBlackboard output_key= output value= mission accomplished / /SequenceStar ForceFailure SetBlackboard output_key= output value= mission failed / /ForceFailure /Fallback /BehaviorTree /root You may notice that: We have a MainTree that includes a subtree called MoveRobot . We want to \"connect\" (i.e. \"remap\") ports inside the MoveRobot subtree with other ports in the MainTree . This is done using the XMl tag , where the words internal/external refer respectively to a subtree and its parent. The following image shows remapping between these two different trees. Note that this diagram represents the dataflow and the entries in the respective blackboard, not the relationship in terms of Behavior Trees. In terms of C++, we don't need to do much. For debugging purpose, we may show some information about the current state of a blackboard with the method debugMessage() . int main () { BT :: BehaviorTreeFactory factory ; factory . registerNodeType SaySomething ( SaySomething ); factory . registerNodeType MoveBaseAction ( MoveBase ); auto tree = factory . createTreeFromText ( xml_text ); NodeStatus status = NodeStatus :: RUNNING ; // Keep on ticking until you get either a SUCCESS or FAILURE state while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); SleepMS ( 1 ); // optional sleep to avoid busy loops } // let s visualize some information about the current state of the blackboards. std :: cout -------------- std :: endl ; tree . blackboard_stack [ 0 ] - debugMessage (); std :: cout -------------- std :: endl ; tree . blackboard_stack [ 1 ] - debugMessage (); std :: cout -------------- std :: endl ; return 0 ; } /* Expected output: [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 [ MoveBase: FINISHED ] Robot says: mission accomplished -------------- move_result (std::string) - full move_goal (Pose2D) - full -------------- output (std::string) - remapped to parent [move_result] target (Pose2D) - remapped to parent [move_goal] -------------- */","title":"Tutorial 6: Ports remapping"},{"location":"tutorial_06_subtree_ports/#remapping-ports-between-trees-and-subtrees","text":"In the CrossDoor example we saw that a SubTree looks like a single leaf Node from the point of view of its parent ( MainTree in the example). Furthermore, to avoid name clashing in very large trees, any tree and subtree use a different instance of the Blackboard. For this reason, we need to explicitly connect the ports of a tree to those of its subtrees. Once again, you won't need to modify your C++ implementation since this remapping is done entirely in the XML definition.","title":"Remapping ports between Trees and SubTrees"},{"location":"tutorial_06_subtree_ports/#example","text":"Let's consider this Beahavior Tree. root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= main_sequence SetBlackboard output_key= move_goal value= 1;2;3 / SubTree ID= MoveRobot target= move_goal output= move_result / SaySomething message= {move_result} / /Sequence /BehaviorTree BehaviorTree ID= MoveRobot Fallback name= move_robot_main SequenceStar MoveBase goal= {target} / SetBlackboard output_key= output value= mission accomplished / /SequenceStar ForceFailure SetBlackboard output_key= output value= mission failed / /ForceFailure /Fallback /BehaviorTree /root You may notice that: We have a MainTree that includes a subtree called MoveRobot . We want to \"connect\" (i.e. \"remap\") ports inside the MoveRobot subtree with other ports in the MainTree . This is done using the XMl tag , where the words internal/external refer respectively to a subtree and its parent. The following image shows remapping between these two different trees. Note that this diagram represents the dataflow and the entries in the respective blackboard, not the relationship in terms of Behavior Trees. In terms of C++, we don't need to do much. For debugging purpose, we may show some information about the current state of a blackboard with the method debugMessage() . int main () { BT :: BehaviorTreeFactory factory ; factory . registerNodeType SaySomething ( SaySomething ); factory . registerNodeType MoveBaseAction ( MoveBase ); auto tree = factory . createTreeFromText ( xml_text ); NodeStatus status = NodeStatus :: RUNNING ; // Keep on ticking until you get either a SUCCESS or FAILURE state while ( status == NodeStatus :: RUNNING ) { status = tree . root_node - executeTick (); SleepMS ( 1 ); // optional sleep to avoid busy loops } // let s visualize some information about the current state of the blackboards. std :: cout -------------- std :: endl ; tree . blackboard_stack [ 0 ] - debugMessage (); std :: cout -------------- std :: endl ; tree . blackboard_stack [ 1 ] - debugMessage (); std :: cout -------------- std :: endl ; return 0 ; } /* Expected output: [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 [ MoveBase: FINISHED ] Robot says: mission accomplished -------------- move_result (std::string) - full move_goal (Pose2D) - full -------------- output (std::string) - remapped to parent [move_result] target (Pose2D) - remapped to parent [move_goal] -------------- */","title":"Example"},{"location":"tutorial_07_legacy/","text":"Wraping legacy code In this tutorial we will see how to deal with legacy code that was not meant to be used with BehaviorTree.CPP. Your class might look like this one: // This is my custom type. struct Point3D { double x , y , z ; }; // We want to create an ActionNode to calls method MyLegacyMoveTo::go class MyLegacyMoveTo { public : bool go ( Point3D goal ) { printf ( Going to: %f %f %f \\n , goal . x , goal . y , goal . z ); return true ; // true means success in my legacy code } }; C++ code As usuall, we need to implement the template specialization of convertFromString . namespace BT { template Point3D convertFromString ( StringView key ) { // three real numbers separated by semicolons auto parts = BT :: splitString ( key , ; ); if ( parts . size () != 3 ) { throw RuntimeError ( invalid input) ); } else { Point3D output ; output . x = convertFromString double ( parts [ 0 ]); output . y = convertFromString double ( parts [ 1 ]); output . z = convertFromString double ( parts [ 2 ]); return output ; } } } // end anmespace BT To wrap the method MyLegacyMoveTo::go , we may use a lambda or std::bind to create a funtion pointer and SimpleActionNode . static const char * xml_text = R ( root BehaviorTree MoveTo goal= -1;3;0.5 / /BehaviorTree /root ) ; int main () { using namespace BT ; MyLegacyMoveTo move_to ; // Here we use a lambda that captures the reference of move_to auto MoveToWrapperWithLambda = [ move_to ]( TreeNode parent_node ) - NodeStatus { Point3D goal ; // thanks to paren_node, you can access easily the inpyt and output ports. parent_node . getInput ( goal , goal ); bool res = move_to . go ( goal ); // convert bool to NodeStatus return res ? NodeStatus :: SUCCESS : NodeStatus :: FAILURE ; }; BehaviorTreeFactory factory ; // Register the lambda with BehaviorTreeFactory::registerSimpleAction PortsList ports = { BT :: InputPort Point3D ( goal ) }; factory . registerSimpleAction ( MoveTo , MoveToWrapperWithLambda , ports ); auto tree = factory . createTreeFromText ( xml_text ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Going to: -1.000000 3.000000 0.500000 */","title":"Tutorial 7: Wrap legacy code"},{"location":"tutorial_07_legacy/#wraping-legacy-code","text":"In this tutorial we will see how to deal with legacy code that was not meant to be used with BehaviorTree.CPP. Your class might look like this one: // This is my custom type. struct Point3D { double x , y , z ; }; // We want to create an ActionNode to calls method MyLegacyMoveTo::go class MyLegacyMoveTo { public : bool go ( Point3D goal ) { printf ( Going to: %f %f %f \\n , goal . x , goal . y , goal . z ); return true ; // true means success in my legacy code } };","title":"Wraping legacy code"},{"location":"tutorial_07_legacy/#c-code","text":"As usuall, we need to implement the template specialization of convertFromString . namespace BT { template Point3D convertFromString ( StringView key ) { // three real numbers separated by semicolons auto parts = BT :: splitString ( key , ; ); if ( parts . size () != 3 ) { throw RuntimeError ( invalid input) ); } else { Point3D output ; output . x = convertFromString double ( parts [ 0 ]); output . y = convertFromString double ( parts [ 1 ]); output . z = convertFromString double ( parts [ 2 ]); return output ; } } } // end anmespace BT To wrap the method MyLegacyMoveTo::go , we may use a lambda or std::bind to create a funtion pointer and SimpleActionNode . static const char * xml_text = R ( root BehaviorTree MoveTo goal= -1;3;0.5 / /BehaviorTree /root ) ; int main () { using namespace BT ; MyLegacyMoveTo move_to ; // Here we use a lambda that captures the reference of move_to auto MoveToWrapperWithLambda = [ move_to ]( TreeNode parent_node ) - NodeStatus { Point3D goal ; // thanks to paren_node, you can access easily the inpyt and output ports. parent_node . getInput ( goal , goal ); bool res = move_to . go ( goal ); // convert bool to NodeStatus return res ? NodeStatus :: SUCCESS : NodeStatus :: FAILURE ; }; BehaviorTreeFactory factory ; // Register the lambda with BehaviorTreeFactory::registerSimpleAction PortsList ports = { BT :: InputPort Point3D ( goal ) }; factory . registerSimpleAction ( MoveTo , MoveToWrapperWithLambda , ports ); auto tree = factory . createTreeFromText ( xml_text ); tree . root_node - executeTick (); return 0 ; } /* Expected output: Going to: -1.000000 3.000000 0.500000 */","title":"C++ code"},{"location":"tutorial_08_additional_args/","text":"Custom initialization and/or construction In every single example we explored so far we were \"forced\" to provide a constructor with the following signature MyCustomNode ( const std :: string name , const NodeConfiguration config ); In same cases, it is desirable to pass to the constructor of our class additional arguments, parameters, pointers, references, etc. We will just use the word \"parameter\" for the rest of the tutorial. Even if, theoretically, these parameters can be passed using Input Ports, that would be the wrong way to do it if: The parameters are know at deployment-time . The parameters don't change at run-time . The parameters don't need to be from the XML . If all these conditions are met, using ports is just cumbersome and highly discouraged. The C++ example Next, we can see two alternative ways to pass parameters to a class: either as arguments of the constructor of the class or in an init() method. // Action_A has a different constructor than the default one. class Action_A : public SyncActionNode { public : // additional arguments passed to the constructor Action_A ( const std :: string name , const NodeConfiguration config , int arg1 , double arg2 , std :: string arg3 ) : SyncActionNode ( name , config ), _arg1 ( arg1 ), _arg2 ( arg2 ), _arg3 ( arg3 ) {} NodeStatus tick () override { std :: cout Action_A: _arg1 / _arg2 / _arg3 std :: endl ; return NodeStatus :: SUCCESS ; } // this example doesn t require any port static PortsList providedPorts () { return {}; } private : int _arg1 ; double _arg2 ; std :: string _arg3 ; }; // Action_B implements an init(...) method that must be called once // before the first tick() class Action_B : public SyncActionNode { public : Action_B ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) {} // we want this method to be called ONCE and BEFORE the first tick() void init ( int arg1 , double arg2 , std :: string arg3 ) { _arg1 = ( arg1 ); _arg2 = ( arg2 ); _arg3 = ( arg3 ); } NodeStatus tick () override { std :: cout Action_B: _arg1 / _arg2 / _arg3 std :: endl ; return NodeStatus :: SUCCESS ; } // this example doesn t require any port static PortsList providedPorts () { return {}; } private : int _arg1 ; double _arg2 ; std :: string _arg3 ; }; The way we register and initialize them in our main is slightly different. static const char * xml_text = R ( root BehaviorTree Sequence Action_A/ Action_B/ /Sequence /BehaviorTree /root ) ; int main () { BehaviorTreeFactory factory ; // A node builder is nothing more than a function pointer to create a // std::unique_ptr TreeNode . // Using lambdas or std::bind, we can easily inject additional arguments. NodeBuilder builder_A = []( const std :: string name , const NodeConfiguration config ) { return std :: make_unique Action_A ( name , config , 42 , 3.14 , hello world ); }; // BehaviorTreeFactory::registerBuilder is a more general way to // register a custom node. factory . registerBuilder Action_A ( Action_A , builder_A ); // The regitration of Action_B is done as usual, but remember // that we still need to call Action_B::init() factory . registerNodeType Action_B ( Action_B ); auto tree = factory . createTreeFromText ( xml_text ); // Iterate through all the nodes and call init() if it is an Action_B for ( auto node : tree . nodes ) { if ( auto action_B_node = dynamic_cast Action_B * ( node . get () )) { action_B_node - init ( 69 , 9.99 , interesting_value ); } } tree . root_node - executeTick (); return 0 ; } /* Expected output: Action_A: 42 / 3.14 / hello world Action_B: 69 / 9.99 / interesting_value */","title":"Tutorial 8: Class parameters"},{"location":"tutorial_08_additional_args/#custom-initialization-andor-construction","text":"In every single example we explored so far we were \"forced\" to provide a constructor with the following signature MyCustomNode ( const std :: string name , const NodeConfiguration config ); In same cases, it is desirable to pass to the constructor of our class additional arguments, parameters, pointers, references, etc. We will just use the word \"parameter\" for the rest of the tutorial. Even if, theoretically, these parameters can be passed using Input Ports, that would be the wrong way to do it if: The parameters are know at deployment-time . The parameters don't change at run-time . The parameters don't need to be from the XML . If all these conditions are met, using ports is just cumbersome and highly discouraged.","title":"Custom initialization and/or construction"},{"location":"tutorial_08_additional_args/#the-c-example","text":"Next, we can see two alternative ways to pass parameters to a class: either as arguments of the constructor of the class or in an init() method. // Action_A has a different constructor than the default one. class Action_A : public SyncActionNode { public : // additional arguments passed to the constructor Action_A ( const std :: string name , const NodeConfiguration config , int arg1 , double arg2 , std :: string arg3 ) : SyncActionNode ( name , config ), _arg1 ( arg1 ), _arg2 ( arg2 ), _arg3 ( arg3 ) {} NodeStatus tick () override { std :: cout Action_A: _arg1 / _arg2 / _arg3 std :: endl ; return NodeStatus :: SUCCESS ; } // this example doesn t require any port static PortsList providedPorts () { return {}; } private : int _arg1 ; double _arg2 ; std :: string _arg3 ; }; // Action_B implements an init(...) method that must be called once // before the first tick() class Action_B : public SyncActionNode { public : Action_B ( const std :: string name , const NodeConfiguration config ) : SyncActionNode ( name , config ) {} // we want this method to be called ONCE and BEFORE the first tick() void init ( int arg1 , double arg2 , std :: string arg3 ) { _arg1 = ( arg1 ); _arg2 = ( arg2 ); _arg3 = ( arg3 ); } NodeStatus tick () override { std :: cout Action_B: _arg1 / _arg2 / _arg3 std :: endl ; return NodeStatus :: SUCCESS ; } // this example doesn t require any port static PortsList providedPorts () { return {}; } private : int _arg1 ; double _arg2 ; std :: string _arg3 ; }; The way we register and initialize them in our main is slightly different. static const char * xml_text = R ( root BehaviorTree Sequence Action_A/ Action_B/ /Sequence /BehaviorTree /root ) ; int main () { BehaviorTreeFactory factory ; // A node builder is nothing more than a function pointer to create a // std::unique_ptr TreeNode . // Using lambdas or std::bind, we can easily inject additional arguments. NodeBuilder builder_A = []( const std :: string name , const NodeConfiguration config ) { return std :: make_unique Action_A ( name , config , 42 , 3.14 , hello world ); }; // BehaviorTreeFactory::registerBuilder is a more general way to // register a custom node. factory . registerBuilder Action_A ( Action_A , builder_A ); // The regitration of Action_B is done as usual, but remember // that we still need to call Action_B::init() factory . registerNodeType Action_B ( Action_B ); auto tree = factory . createTreeFromText ( xml_text ); // Iterate through all the nodes and call init() if it is an Action_B for ( auto node : tree . nodes ) { if ( auto action_B_node = dynamic_cast Action_B * ( node . get () )) { action_B_node - init ( 69 , 9.99 , interesting_value ); } } tree . root_node - executeTick (); return 0 ; } /* Expected output: Action_A: 42 / 3.14 / hello world Action_B: 69 / 9.99 / interesting_value */","title":"The C++ example"},{"location":"tutorial_09_coroutines/","text":"Async Actions using Coroutines BehaviorTree.CPP provides two easy-to-use abstractions to create an asynchronous Action, i.e. those actions which: Take a long time to be concluded. May return \"RUNNING\". Can be halted . The first class is a AsyncActionNode that executes the tick() method in a separate thread . In this tutorial, we introduce the CoroActionNode , a different action that uses coroutines to achieve similar results. The main reason is that Coroutines do not spawn a new thread and are much more efficient. Furthermore, you don't need to worry about thread-safety in your code... In Coroutines, the user should explicitly call a yield method when he/she wants the execution of the Action to be suspended. CoroActionNode wraps this yield function into a convenient method setStatusRunningAndYield() . The C++ source example The next example can be used as a \"template\" for your own implementation. typedef std :: chrono :: milliseconds Milliseconds ; class MyAsyncAction : public CoroActionNode { public : MyAsyncAction ( const std :: string name ) : CoroActionNode ( name , {}) {} private : // This is the ideal skeleton/template of an async action: // - A request to a remote service provider. // - A loop where we check if the reply has been received. // - You may call setStatusRunningAndYield() to pause . // - Code to execute after the reply. // - A simple way to handle halt(). NodeStatus tick () override { std :: cout name () : Started. Send Request to server. std :: endl ; TimePoint initial_time = Now (); TimePoint time_before_reply = initial_time + Milliseconds ( 100 ); int count = 0 ; bool reply_received = false ; while ( ! reply_received ) { if ( count ++ == 0 ) { // call this only once std :: cout name () : Waiting Reply... std :: endl ; } // pretend that we received a reply if ( Now () = time_before_reply ) { reply_received = true ; } if ( ! reply_received ) { // set status to RUNNING and pause/sleep // If halt() is called, we will NOT resume execution setStatusRunningAndYield (); } } // This part of the code is never reached if halt() is invoked, // only if reply_received == true; std :: cout name () : Done. Waiting Reply loop repeated count times std :: endl ; cleanup ( false ); return NodeStatus :: SUCCESS ; } // you might want to cleanup differently if it was halted or successful void cleanup ( bool halted ) { if ( halted ) { std :: cout name () : cleaning up after an halt() \\n std :: endl ; } else { std :: cout name () : cleaning up after SUCCESS \\n std :: endl ; } } void halt () override { std :: cout name () : Halted. std :: endl ; cleanup ( true ); // Do not forget to call this at the end. CoroActionNode :: halt (); } Timepoint Now () { return std :: chrono :: high_resolution_clock :: now (); }; }; As you may have noticed, the action \"pretends\" to wait for a request message; the latter will arrive after 100 milliseconds . To spice things up, we create a Sequence with two actions, but the entire sequence will be halted by a timeout after 150 millisecond . root BehaviorTree Timeout msec= 150 SequenceStar name= sequence MyAsyncAction name= action_A / MyAsyncAction name= action_B / /SequenceStar /Timeout /BehaviorTree /root No surprises in the main() ... int main () { // Simple tree: a sequence of two asycnhronous actions, // but the second will be halted because of the timeout. BehaviorTreeFactory factory ; factory . registerNodeType MyAsyncAction ( MyAsyncAction ); auto tree = factory . createTreeFromText ( xml_text ); //--------------------------------------- // keep executin tick until it returns etiher SUCCESS or FAILURE while ( tree . root_node - executeTick () == NodeStatus :: RUNNING ) { std :: this_thread :: sleep_for ( Milliseconds ( 10 ) ); } return 0 ; } /* Expected output: action_A: Started. Send Request to server. action_A: Waiting Reply... action_A: Done. Waiting Reply loop repeated 11 times action_A: cleaning up after SUCCESS action_B: Started. Send Request to server. action_B: Waiting Reply... action_B: Halted. action_B: cleaning up after an halt() */","title":"Tutorial 9: Coroutines"},{"location":"tutorial_09_coroutines/#async-actions-using-coroutines","text":"BehaviorTree.CPP provides two easy-to-use abstractions to create an asynchronous Action, i.e. those actions which: Take a long time to be concluded. May return \"RUNNING\". Can be halted . The first class is a AsyncActionNode that executes the tick() method in a separate thread . In this tutorial, we introduce the CoroActionNode , a different action that uses coroutines to achieve similar results. The main reason is that Coroutines do not spawn a new thread and are much more efficient. Furthermore, you don't need to worry about thread-safety in your code... In Coroutines, the user should explicitly call a yield method when he/she wants the execution of the Action to be suspended. CoroActionNode wraps this yield function into a convenient method setStatusRunningAndYield() .","title":"Async Actions using Coroutines"},{"location":"tutorial_09_coroutines/#the-c-source-example","text":"The next example can be used as a \"template\" for your own implementation. typedef std :: chrono :: milliseconds Milliseconds ; class MyAsyncAction : public CoroActionNode { public : MyAsyncAction ( const std :: string name ) : CoroActionNode ( name , {}) {} private : // This is the ideal skeleton/template of an async action: // - A request to a remote service provider. // - A loop where we check if the reply has been received. // - You may call setStatusRunningAndYield() to pause . // - Code to execute after the reply. // - A simple way to handle halt(). NodeStatus tick () override { std :: cout name () : Started. Send Request to server. std :: endl ; TimePoint initial_time = Now (); TimePoint time_before_reply = initial_time + Milliseconds ( 100 ); int count = 0 ; bool reply_received = false ; while ( ! reply_received ) { if ( count ++ == 0 ) { // call this only once std :: cout name () : Waiting Reply... std :: endl ; } // pretend that we received a reply if ( Now () = time_before_reply ) { reply_received = true ; } if ( ! reply_received ) { // set status to RUNNING and pause/sleep // If halt() is called, we will NOT resume execution setStatusRunningAndYield (); } } // This part of the code is never reached if halt() is invoked, // only if reply_received == true; std :: cout name () : Done. Waiting Reply loop repeated count times std :: endl ; cleanup ( false ); return NodeStatus :: SUCCESS ; } // you might want to cleanup differently if it was halted or successful void cleanup ( bool halted ) { if ( halted ) { std :: cout name () : cleaning up after an halt() \\n std :: endl ; } else { std :: cout name () : cleaning up after SUCCESS \\n std :: endl ; } } void halt () override { std :: cout name () : Halted. std :: endl ; cleanup ( true ); // Do not forget to call this at the end. CoroActionNode :: halt (); } Timepoint Now () { return std :: chrono :: high_resolution_clock :: now (); }; }; As you may have noticed, the action \"pretends\" to wait for a request message; the latter will arrive after 100 milliseconds . To spice things up, we create a Sequence with two actions, but the entire sequence will be halted by a timeout after 150 millisecond . root BehaviorTree Timeout msec= 150 SequenceStar name= sequence MyAsyncAction name= action_A / MyAsyncAction name= action_B / /SequenceStar /Timeout /BehaviorTree /root No surprises in the main() ... int main () { // Simple tree: a sequence of two asycnhronous actions, // but the second will be halted because of the timeout. BehaviorTreeFactory factory ; factory . registerNodeType MyAsyncAction ( MyAsyncAction ); auto tree = factory . createTreeFromText ( xml_text ); //--------------------------------------- // keep executin tick until it returns etiher SUCCESS or FAILURE while ( tree . root_node - executeTick () == NodeStatus :: RUNNING ) { std :: this_thread :: sleep_for ( Milliseconds ( 10 ) ); } return 0 ; } /* Expected output: action_A: Started. Send Request to server. action_A: Waiting Reply... action_A: Done. Waiting Reply loop repeated 11 times action_A: cleaning up after SUCCESS action_B: Started. Send Request to server. action_B: Waiting Reply... action_B: Halted. action_B: cleaning up after an halt() */","title":"The C++ source example"},{"location":"tutorials_summary/","text":"Summary of the tutorials T.1: Create your first Behavior Tree This tutorial demonstrates how to create custom ActionNodes in C++ and how to compose them into Trees using the XML language. T.2: Parametrize a Node with Ports TreeNodes can have both Inputs and Outputs Ports. This tutorial demonstrates how to use ports to create parametrized Nodes. T.3: Generic and type-safe Ports This tutorial is an extension of the previous one. It shows how to create and use ports with generic and user-defined types. T.4: Difference between Sequence and ReactiveSequence Reactive ControlNodes can be a very powerful tool to create sophisticated behaviors. This example shows the difference between a standard Sequence and a Reactive one. T.5: How to reuse entire SubTrees Reusability and Composability can be done at the level of a single Node, but also with entire Trees, which can become SubTrees of a \"parent\" Tree. In this tutorial we will also introduce the builtin Loggers. T.6: Remapping of Ports between SubTrees and their parents Any Tree/SubTree in the system has its own isolated BlackBoard. In this tutorial we extend the concept or Ports to SubTrees, using port remapping. T.7: How to wrap legacy code in a non intrusive way This tutorial shows one of the many possible ways to wrap an existing code into the BehavioTree.CPP infrastructure. T.8: Passing arguments to Nodes without Ports If your custom Node has a lot of ports, it is probably a sign that you didn't understand the problem that Ports are supposed to solve ;) In this tutorial, we show how to pass arguments to a custom Node class without polluting your interfaces with pointless Input Ports. T.9: Asynchronous actions with Coroutines Coroutines are a powerful tool to create asynchronous code. In this tutorial, we outline the typical design pattern to use when you implement an asynchronous Action using CoroActionNode .","title":"Summary"},{"location":"tutorials_summary/#summary-of-the-tutorials","text":"","title":"Summary of the tutorials"},{"location":"tutorials_summary/#t1-create-your-first-behavior-tree","text":"This tutorial demonstrates how to create custom ActionNodes in C++ and how to compose them into Trees using the XML language.","title":"T.1: Create your first Behavior Tree"},{"location":"tutorials_summary/#t2-parametrize-a-node-with-ports","text":"TreeNodes can have both Inputs and Outputs Ports. This tutorial demonstrates how to use ports to create parametrized Nodes.","title":"T.2: Parametrize a Node with Ports"},{"location":"tutorials_summary/#t3-generic-and-type-safe-ports","text":"This tutorial is an extension of the previous one. It shows how to create and use ports with generic and user-defined types.","title":"T.3: Generic and type-safe Ports"},{"location":"tutorials_summary/#t4-difference-between-sequence-and-reactivesequence","text":"Reactive ControlNodes can be a very powerful tool to create sophisticated behaviors. This example shows the difference between a standard Sequence and a Reactive one.","title":"T.4: Difference between Sequence and ReactiveSequence"},{"location":"tutorials_summary/#t5-how-to-reuse-entire-subtrees","text":"Reusability and Composability can be done at the level of a single Node, but also with entire Trees, which can become SubTrees of a \"parent\" Tree. In this tutorial we will also introduce the builtin Loggers.","title":"T.5: How to reuse entire SubTrees"},{"location":"tutorials_summary/#t6-remapping-of-ports-between-subtrees-and-their-parents","text":"Any Tree/SubTree in the system has its own isolated BlackBoard. In this tutorial we extend the concept or Ports to SubTrees, using port remapping.","title":"T.6: Remapping of Ports between SubTrees and their parents"},{"location":"tutorials_summary/#t7-how-to-wrap-legacy-code-in-a-non-intrusive-way","text":"This tutorial shows one of the many possible ways to wrap an existing code into the BehavioTree.CPP infrastructure.","title":"T.7: How to wrap legacy code in a non intrusive way"},{"location":"tutorials_summary/#t8-passing-arguments-to-nodes-without-ports","text":"If your custom Node has a lot of ports, it is probably a sign that you didn't understand the problem that Ports are supposed to solve ;) In this tutorial, we show how to pass arguments to a custom Node class without polluting your interfaces with pointless Input Ports.","title":"T.8: Passing arguments to Nodes without Ports"},{"location":"tutorials_summary/#t9-asynchronous-actions-with-coroutines","text":"Coroutines are a powerful tool to create asynchronous code. In this tutorial, we outline the typical design pattern to use when you implement an asynchronous Action using CoroActionNode .","title":"T.9: Asynchronous actions with Coroutines"},{"location":"xml_format/","text":"Basics of the XML schema In the first tutorial this simple tree was presented. root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething name= action_hello message= Hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root You may notice that: The first tag of the tree is root . It should contain 1 or more tags BehaviorTree . The tag BehaviorTree should have the attribute [ID] . The tag root should contain the attribute [main_tree_to_execute] . The attribute [main_tree_to_execute] is mandatory if the file contains multiple BehaviorTree , optional otherwise. Each TreeNode is represented by a single tag. In particular: The name of the tag is the ID used to register the TreeNode in the factory. The attribute [name] refers to the name of the instance and is optional . Ports are configured using attributes. In the previous example, the action SaySomething requires the input port message . In terms of number of children: ControlNodes contain 1 to N children . DecoratorNodes and Subtrees contain only 1 child . ActionNodes and ConditionNodes have no child . Ports Remapping and pointers to Blackboards entries As explained in the second tutorial input/output ports can be remapped using the name of an entry in the Blackboard, in other words, the key of a key/value pair of the BB. An BB key is represented using this syntax: {key_name} . In the following example: the first child of the Sequence prints \"Hello\", the second child reads and writes the value contained in the entry of the blackboard called \"my_message\"; root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething message= Hello / SaySomething message= {my_message} / /Sequence /BehaviorTree /root Compact vs Explicit representation The following two syntaxes are both valid: SaySomething name= action_hello message= Hello World / Action ID= SaySomething name= action_hello message= Hello World / We will call the former syntax \" compact \" and the latter \" explicit \". The first example represented with the explicit syntax would become: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence Action ID= SaySomething name= action_hello message= Hello / Action ID= OpenGripper name= open_gripper / Action ID= ApproachObject name= approach_object / Action ID= CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Even if the compact syntax is more convenient and easier to write, it provides too little information about the model of the TreeNode. Tools like Groot require either the explicit syntax or additional information. This information can be added using the tag TreeNodeModel . To make the compact version of our tree compatible with Groot, the XML must be modified as follows: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething name= action_hello message= Hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree !-- the BT executor don t require this, but Groot does -- TreeNodeModel Action ID= SaySomething input_port name= message type= std::string / /Action Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /TreeNodeModel /root XML Schema available for explicit version You can download the XML Schema here: behaviortree_schema.xsd . Subtrees As we saw in this tutorial , it is possible to include a Subtree inside another tree to avoid \"copy and pasting\" the same tree in multiple location and to reduce complexity. Let's say that we want to incapsulate few action into the behaviorTree \" GraspObject \" (being optional, attributes [name] are omitted for simplicity). root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence Action ID= SaySomething message= Hello World / Subtree ID= GraspObject / /Sequence /BehaviorTree BehaviorTree ID= GraspObject Sequence Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /Sequence /BehaviorTree /root We may notice as the entire tree \"GraspObject\" is executed after \"SaySomething\". Include external files Since version 2.4 . You can include external files in a way that is similar to #include in C++. We can do this easily using the tag: include path= relative_or_absolute_path_to_file using the previous example, we may split the two behavior trees into two files: !-- file maintree.xml -- root main_tree_to_execute = MainTree include path= grasp.xml / BehaviorTree ID= MainTree Sequence Action ID= SaySomething message= Hello World / Subtree ID= GraspObject / /Sequence /BehaviorTree /root !-- file grasp.xml -- root main_tree_to_execute = GraspObject BehaviorTree ID= GraspObject Sequence Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /Sequence /BehaviorTree /root Note for ROS users If you want to find a file inside a ROS package , you can use this syntax: include ros_pkg=\"name_package\" path=\"path_relative_to_pkg/grasp.xml\"/","title":"The XML format"},{"location":"xml_format/#basics-of-the-xml-schema","text":"In the first tutorial this simple tree was presented. root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething name= action_hello message= Hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree /root You may notice that: The first tag of the tree is root . It should contain 1 or more tags BehaviorTree . The tag BehaviorTree should have the attribute [ID] . The tag root should contain the attribute [main_tree_to_execute] . The attribute [main_tree_to_execute] is mandatory if the file contains multiple BehaviorTree , optional otherwise. Each TreeNode is represented by a single tag. In particular: The name of the tag is the ID used to register the TreeNode in the factory. The attribute [name] refers to the name of the instance and is optional . Ports are configured using attributes. In the previous example, the action SaySomething requires the input port message . In terms of number of children: ControlNodes contain 1 to N children . DecoratorNodes and Subtrees contain only 1 child . ActionNodes and ConditionNodes have no child .","title":"Basics of the XML schema"},{"location":"xml_format/#ports-remapping-and-pointers-to-blackboards-entries","text":"As explained in the second tutorial input/output ports can be remapped using the name of an entry in the Blackboard, in other words, the key of a key/value pair of the BB. An BB key is represented using this syntax: {key_name} . In the following example: the first child of the Sequence prints \"Hello\", the second child reads and writes the value contained in the entry of the blackboard called \"my_message\"; root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething message= Hello / SaySomething message= {my_message} / /Sequence /BehaviorTree /root","title":"Ports Remapping and pointers to Blackboards entries"},{"location":"xml_format/#compact-vs-explicit-representation","text":"The following two syntaxes are both valid: SaySomething name= action_hello message= Hello World / Action ID= SaySomething name= action_hello message= Hello World / We will call the former syntax \" compact \" and the latter \" explicit \". The first example represented with the explicit syntax would become: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence Action ID= SaySomething name= action_hello message= Hello / Action ID= OpenGripper name= open_gripper / Action ID= ApproachObject name= approach_object / Action ID= CloseGripper name= close_gripper / /Sequence /BehaviorTree /root Even if the compact syntax is more convenient and easier to write, it provides too little information about the model of the TreeNode. Tools like Groot require either the explicit syntax or additional information. This information can be added using the tag TreeNodeModel . To make the compact version of our tree compatible with Groot, the XML must be modified as follows: root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence name= root_sequence SaySomething name= action_hello message= Hello / OpenGripper name= open_gripper / ApproachObject name= approach_object / CloseGripper name= close_gripper / /Sequence /BehaviorTree !-- the BT executor don t require this, but Groot does -- TreeNodeModel Action ID= SaySomething input_port name= message type= std::string / /Action Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /TreeNodeModel /root XML Schema available for explicit version You can download the XML Schema here: behaviortree_schema.xsd .","title":"Compact vs Explicit representation"},{"location":"xml_format/#subtrees","text":"As we saw in this tutorial , it is possible to include a Subtree inside another tree to avoid \"copy and pasting\" the same tree in multiple location and to reduce complexity. Let's say that we want to incapsulate few action into the behaviorTree \" GraspObject \" (being optional, attributes [name] are omitted for simplicity). root main_tree_to_execute = MainTree BehaviorTree ID= MainTree Sequence Action ID= SaySomething message= Hello World / Subtree ID= GraspObject / /Sequence /BehaviorTree BehaviorTree ID= GraspObject Sequence Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /Sequence /BehaviorTree /root We may notice as the entire tree \"GraspObject\" is executed after \"SaySomething\".","title":"Subtrees"},{"location":"xml_format/#include-external-files","text":"Since version 2.4 . You can include external files in a way that is similar to #include in C++. We can do this easily using the tag: include path= relative_or_absolute_path_to_file using the previous example, we may split the two behavior trees into two files: !-- file maintree.xml -- root main_tree_to_execute = MainTree include path= grasp.xml / BehaviorTree ID= MainTree Sequence Action ID= SaySomething message= Hello World / Subtree ID= GraspObject / /Sequence /BehaviorTree /root !-- file grasp.xml -- root main_tree_to_execute = GraspObject BehaviorTree ID= GraspObject Sequence Action ID= OpenGripper / Action ID= ApproachObject / Action ID= CloseGripper / /Sequence /BehaviorTree /root Note for ROS users If you want to find a file inside a ROS package , you can use this syntax: include ros_pkg=\"name_package\" path=\"path_relative_to_pkg/grasp.xml\"/","title":"Include external files"}]}